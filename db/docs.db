{"dirName":"codesafer","subName":"개념글","fileName":"복잡한 클래싱 구조에서 부모 클래스의 생성자가 컨테이너에 추가한다는것","fileData":"## 복잡한 클래싱 구조에서 부모 클래스의 생성자가 컨테이너에 추가한다는것.\n\n``` cpp\nclass SOME_OBJECT ... // 추상 클래스\n\n// AddChild 멤버함수를 갖고 destructor 에서 Children 을 삭제하는 역할 담당.\n// Singleton 일 수 있음.\nclass CONTAINER : public SOME_OBJECT ...\n\nCONTAINER* container; // 할당되어 있다 치자\n\nclass PARENT : public SOME_OBJECT\n{\npublic:\n    PARENT( SOME_OBJECT* owner )\n    {\n        owner->AddChild( this );\n    }\n};\n\nclass CHILD : public PARENT\n{\n    using inherited = PARENT; // 이러면 super 처럼 쓸 수 있음\npublic:\n    CHILD( SOME_OBJECT* owner ) : PARENT( owner ){} // 자식 클래스들을 만들때 마다 부모로 릴레이\n};\n\n**** N 개의 child class 를 추가 개발하면서 container 에 대해 알 필요가 없음\n**** 오로지 부모 생성자 초기화 만으로 새로운 클래스 참여 완료.\n\n//////////////////////////////////// 여기까진 프레임웍 개발 타임\n여기서부터 가져다 쓰는 시점 ////////////////////////////////////\n\n1. 가져다 쓸때 CHILD 의 다른 프로퍼티를 건드릴 필요 없으면\nnew CHILD( container );\n\n2. 다른 프로퍼티에 접근해야 할 때\nCHILD* child = new CHILD( container );\nchild->blahblaa...\nchild->blahblaa...\n\n**** 1. 2 두 케이스 모두 생성자와 container 라는 이름만 접근.\n\n///////////////////////////////////////////////////////////////////////////////////////\n\n아래는 이렇게 구현되어 있지 않을 경우.\n\n1. 가져다 쓸때 CHILD 의 다른 프로퍼티를 건드릴 필요 없으면\ncontainer->AddChild( new CHILD );\n\n2. 다른 프로퍼티에 접근해야 할 때\nCHILD* child = new CHILD;\nchild->blahblaa...\nchild->blahblaa...\ncontainer->AddChild( child );\n\n**** 1. 2 두 케이스 모두 생성자와 container 라는 이름 외에 AddChild 라는 멤버함수를 기억+사용해야 접근.\n```\n\n어느쪽이 더 편하냐? ( 대소문자 까지 기억해야 되면 더 귀찮지 )\n\n두 코드의 기능에 차이가 있냐? No\n손품은 후자가 더 팔지? Yes\n\n어느쪽을 선택하든 자유야. 동작도 같아. ㅉㅉ\n난 커졌을 때 손 덜가고 기억 덜하는 코드를 택하겠다 이거야.\n","btime":{"$$date":1478745281329},"mtime":{"$$date":1478745281329},"_id":"077RnDO7uqmnGufa"}
{"dirName":"codesafer","subName":"개념글","fileName":"shared_mutex 란","fileData":"## shared_mutex 란\n\nboost 에선 세가지 모드를 지원하는걸로 기억하는데,\n\nstl 에서 제공하는 shared_mutex 는 upgradable 인가를 지원안할거임.\n그래서 exclusive mode 랑 shared mode 두가지를 지원함.\n\n한마디로, ( exclusive ) unique_lock 은 기존의 mutex 를 lock 하는것과 거의 같은 동작임.\n누가 lock 을 걸었으면 걔가 풀때까지 자원에 접근할 수 없음.\n\nshared_lock 을 걸면 shared_lock 을 건 쓰레드들끼리는 읽기 전용으로 접근한다는 약속하에 접근이 허가됨.\n\n무슨 말인고 하니,\n\n어떤 상점에 물건을 파는데, 구경은 공짜, 살 사람만 만지시오. 라고 써붙인 상황인것임.\n\n1. 어떤 사람이 사려고 만지는 동안은 아무도 구경 못함. ( unique_lock 일때는 shared_lock 이 걸리지 않음 )\n2. 구경하는 사람이 있을땐 구경은 할 수 있음 ( shared_lock 일때, 다른 쓰레드도 shared_lock 가능 )\n3. 구경하는 사람이 있을땐 사지도 못함 ( shared_lock 일때, unique_lock 을 걸 수 없음 )\n4. 당연하지만 사려는 사람이 만지는 동안은 다른 사람이 사려고 만질 수 없음 ( unique_lock 일때 unique_lock 을 걸 수 없음 )\n\n즉, 읽기용 락은 복수가 가능하지만 읽기용 락중엔 쓰기용 락이 안됨.\n쓰기용 락일 때는 추가로 읽기용 락도 안되고 쓰기용 락도 안됨.\n\n수정등의 공유데이타 변경을 한 쓰레드에서만 하고 여러쓰레드에서는 읽기만 할때,\n읽는 애들끼리 lock 의 방해를 주고 받지 않도록 유연성을 부여해 설계된 mutex 란거임.\n","btime":{"$$date":1478744786451},"mtime":{"$$date":1478744786451},"_id":"15gDTErSTnclrQoX"}
{"dirName":"codesafer","subName":"개념글","fileName":"재귀를 거의 그대로 iteration 으로 바꾸는 기본 구조","fileData":"## 재귀를 거의 그대로 iteration 으로 바꾸는 기본 구조\n```cpp\n#include <iostream>\n\nusing   namespace   std;\n\nint run_ladder( int level = 0, int index = 0 )\n{\n    if( level >= 4 ) return 1;\n    index += ++level;    \n    return run_ladder( level, index ) + run_ladder( level, index + 1 );\n}\n\nint run_ladder_iteration()\n{\n    static  char    output[6];\n    typedef struct\n    {\n        int level,  index;\n    };\n    CONTEXT;\n    CONTEXT     stack[5], now;\n    int         sp = 1;\n    int         result = 0;\n    stack[0] = { 0, 0 };\n\n    while( sp )\n    {\n        now = stack[--sp];\n        while( 1 )\n        {\n            output[ now.level ] = 'A' + now.index;\n            if( now.level >= 4 )\n            {\n                cout << output << endl;\n                break;\n            }\n            now.index += ++now.level;\n            stack[sp++] = { now.level, now.index + 1 };\n        }\n        result++;\n    }\n    return result;\n}\n\n\nint main()\n{\n    cout << run_ladder() << endl;\n    cout << run_ladder_iteration() << endl;\n    return 0;\n}\n```\n한심한 문제.\n","btime":{"$$date":1478745374741},"mtime":{"$$date":1478745374741},"_id":"2P6ePTgwiX0cuJfa"}
{"dirName":"codesafer","subName":"코딩 모범에 관한 코멘터리","fileName":"1","fileData":"의미를 전달할 수 있는 변수 이름을 붙여 주세요\n-> 당연\n\n매직 넘버에는 이름을 붙여주세요\n-> 물론 가급적 모든 상수엔 이름을 붙이는게 좋습니다. 이터레이터의 0, 1 정도가 가끔 예외\n-> 상수는 변수와 달리 오히려 강한 의미를 갖고 있습니다.\n-> 그래서 네이밍하기도 편하고 네이밍 해두면 소스코드가 사람말에 가깝게 읽혀지게 되죠.\n\n복잡한 조건식은 함수화해주세요\n-> 어디를 자르느냐가 관건. 조건에도 의미가 있습니다. 그 의미를 따서 함수명으로 사용하면,\n-> 조건을 해석해서 의미를 파악하는게 아니라 그냥 읽으면 되죠.\n\n계산식을 함수화해서 의미를 전달하세요.\n-> 계산식에 이름을 붙이다 보면 유사한 유형들이 하나로 통합 정리되어 가고,\n-> 재사용성을 높일수 있을 뿐더러, 역시 사람말로 읽을 수 있는 코드가 됩니다.\n-> 컴파일러가 좋아지니 주저할 필요 없습니다. 가장 단순하고 직관적인 단어를 찾아 이름을 붙이세요.\n\n사전 조건과 사후 조건은 assert로 명시해주세요.\n-> 이런 일이 있어선 안돼! 를 명시하기 좋습니다.\n-> 만약 프로그램 실행을 더이상 진행했다간 큰일이 날 것 같을 땐 가차없이 그만둬야죠.\n-> 피가 퐁퐁 솟아나는데 수술을 계속할 순 없는 일.\n-> 예기치 않게 데이타 파일을 깨먹는다든지 엉뚱한 패킷을 날려서 계좌가 털려버릴 수도 있으니까요.\n\n사소한 중복도 티끌모아 태산이 되므로 줄여주세요.\n-> 동어반복과 중복의 제거는 성능과 재사용성,\n-> 관리의 유용성 ( 관리포인트의 단일화 ) 를 위해 필수적인 요소입니다.\n\n조기 리턴을 활용해 주세요.\n-> 함수 안에서 if ( ... ) return; 을 사용하면 불필요한 들여쓰기를 줄일 수 있습니다.\n-> 배제할 수 있는 조건의 우선 배제는 뒤에 실행되는 코드의 논리를 가볍게 합니다.\n-> 일찍 처리할 수 있는 일 부터 끝내고 노는게 여러가지 일을 양 손에 들고 고민하는 것 보다 편하죠.\n-> break, break 릴레이 하는 것에 비해 나은 성능을 발휘 할 수 있습니다.\n\nif 조건문을 작고 단순하게 만들어주세요.\n-> 당연히 성능과 직관적 읽기, 논리적 허점을 줄이기 위해서 불필요한 논리의 열거는 지양해야합니다.\n\n자료구조를 활용해서 if 조건문을 줄여보세요.\n-> 무분기 의 장점은 흐름을 단일화 하고, 파이프라인 효율을 높이게 해 줍니다.\n-> 다만 가끔 if 한개가 깔끔하고 성능도 빠른 경우가 있으니 집착할 필욘 없습니다.\n\nnull을 체크하지 않아도 되는 방법을 생각해보세요.\n-> 보통 null 을 체크하는 경우는 두 가지죠. 객체의 소멸 시점이 복잡한 경우,\n-> 루프 안에서 복수개의 조건이 존재하는 경우.\n-> 이때 객체의 소멸 시점을 보다 근본적으로 일괄 관리할 수 있도록 구조를 고민하는게\n-> 뒷처리하는것 보다 튼튼한 구조입니다.\n-> 문자열 함수처럼 루프 안에 존재하는 여러 조건들이 null 을 만날때 까지 무한히 돌아야 하는 경우는 드뭅니다.\n-> strncpy 같은게 있는 이유는 안정성을 높이기 위해서죠.\n-> 반대로 두개 이상의 논리적 조건이, 하나의 더 빠른 논리적 조건에 가려질 수 있을 때,\n-> 빠른 조건을 선택하는게 당연히 성능에도 좋습니다.\n","btime":{"$$date":1478746034466},"mtime":{"$$date":1478746034466},"_id":"3X5DMZ2ZSuCO9R7f"}
{"dirName":"codesafer","subName":"초보를 위한 강좌","fileName":"01. 우리는 어떤 언어를 선택해야하는가","fileData":"### 우리는 어떤 언어를 선택해야 하는가.\n\n기준 : 지극히 코세 기준, 나열순서 알파벳순.\n\n기존의 시장이 큰 언어\nC++, C# ( Unity 버프 ), Java\n\n편리한 언어\nJavaScript, Python\n\n불편한 언어\nAssembly ( 딱히 어렵진 않지만 이거 뭐 시대착오적 )\n\n개념화가 잘 된 언어\nClojure, Haskell, Julia\n\n신흥강자\nSwift ( 언어가 공개된 만큼 귀추 주목 )\n\n나머지\nGo, R, Rust 및 듣보잡. ( 은 아니고 내가 관심 없음 )\n\n  Clojure 도 Java 기반이니 만큼 자바의 위용은 무시하기 힘듦.\n  JavaScript 는 이름만 Java 일 뿐.\n\n초보자의 선택 기준.\n무조건 쉬운거 부터 Python, JavaScript 강추.\n\n고급자의 선택 기준.\n1. C++\n   왜? 더럽고 강력하니까.\n   언어적 경험을 꽤 갖고있고, 수많은 문법적 비직관성을 정리해낼 능력이 있거나\n   정리 능력을 기르고싶은 사람에게 추천.\n\n2. Haskell, Clojure\n   왜? 논리 자체에 집중하게 해주니까.\n   언어가 갖고 있는 함수적 개념 자체가 다른 언어에도 적용할 수 있어서\n   다른 언어를 향상시킬 수 있을 만큼 일반성을 가짐.\n","btime":{"$$date":1478745899154},"mtime":{"$$date":1478746020831},"_id":"4ysqVwfQK3av1dVj"}
{"dirName":"codesafer","subName":"뻘소리","fileName":"잡스가 그랬잖아","fileData":"## 잡스가 그랬잖아\n\n전국민이 프로그래밍을 배워야하는 이유는 생각하는 법을 배우기 위함 이라고.\n생각하는 법, 사고하는 법 이라는게 컨테이너, 래퍼 이상 아무것도 아니거든.\n\n무언가를 담아야지.\n\n단순히 남이 만들어 놓은 틀 위에서 절차적으로 나열해\n남들 다 할 수 있는 바이너리를 생산하는 정도에서 안주하니까 문제가 되는 것.\n\n그런건 식당 간판 만드는 간판쟁이랑 다를 바 없다고 봐.\n\n프로그래밍을 열심히 공부하는 친구들은\n문제를 해결할 수 있는 능력을 키우려고 부단히 노력하고 있고,\n\n1. 정보를 보다 효과적으로 전달하기 위한 시각화\n2. 다양한 형태로 구체화 할 때 뼈대가될 본질을 향한 추상화\n3. 각각의 구체적인 용례에 적합한 도구의 확보\n4. 모범이 되는 대안의 제시\n5. 지식과 학문의 통합\n\n을 향하고 있는데, 그걸 사람들에게 알려주기 곤란한건 어쩔 수 없는거야.\n어차피 컴맹들 눈엔 타자 빠르고 연봉 많으면 대단한거니까 말야.\n그런 무식한 시선들은 일일이 신경쓸 필요가 없다고 봐.\n\n다른 이공계열이든 수학이든 철학이든,\n자신이 공부하던 학문을 세상으로 가지고 오고,\n세상을 학문으로 옮겨놓기 위해 노력하다 보면\n결국 범용 계산 환경인 컴퓨터와 도구 언어의 중요성을 실감할 수 밖에 없고,\n그걸 잘 다루는 사람이 프로그래머인거니까.\n\n소비자에게 한 걸음 다가가지 않으면,\n제 아무리 멋진 학문이라도 배고플 수 밖에 없어.\n그러니까 프로그래밍은 어떤 의미에서 지독하게 생존지향적인 학문일 수 있지.\n","btime":{"$$date":1478745812204},"mtime":{"$$date":1478745812204},"_id":"8e6iU41hF3Es4wKA"}
{"dirName":"codesafer","subName":"C++ 에서 전역변수 사용의 득과 실","fileName":"2","fileData":"## C/ C++ 에서 전역변수 사용의 득과 실\n\n앞서 memory compaction 을 이야기 했지만,\n뭔가 다른 쓰레드 ( Garbage collector ) 가 임의로 메모리를 정리해 버린다는건,\n내가 이미 할당해서 변수에 저장한 메모리 주소의 내용이 나도 모르는 사이 다른 주소로 옮겨져 버린다는걸 의미해.\n\n그래서 주소가 아닌 handle 개념이 도입되게 되고,\n주소 그자체의 개념인 포인터가 사라질 수 밖에 없어지는거지.\n그게 Java 와 C# 의 특징이야. ( C#에는 locking 해서 접근하는 약간의 융통성이 있지만 )\n그렇게 자원을 우회해서 접근하면 성능이 떨어지게 되지. 얼마나? 보통 2배 느려짐.\n거기다 쓰레드가 돌게 되니까 보통은 5배 느려짐. 물론 CPU 가 아닌 VM 위에서 해석해 도는 비용도 포함.\n이도 저도 다 빼고 미친듯 최적화 해 버리면 Java 꼴이 Java 꼴이 아니게 되어버리지. 안습.\n그래봐야 C 보다 느릴 수 밖에 없지만.\n\nhandle 이란 개념은 ( 보다 안전하고, 적은 힘을 들여 대상을 다룰 수 있는 매개체 의 개념이야 )\n십자드라이버의 손잡이나, 자동차의 핸들을 상상하면 적당해.\n그게 컴퓨터에서는 간단히는 정수->주소 형태의 테이블로 구현이 되지.\n그러니까 Java like 한 언어에서는 내부적으로 자원1, 자원2 라는 핸들 ( 숫자 ) 단위로 사용할 자원을 명시하고,\nGarbage Collector 가 그 해당 자원 번호가 어느 주소를 가리킬지를 변경하고 있다고 보면 되는 것.\n\n전역으로 할당한 큰 메모리, 혹은 heap 에 할당한 더 큰 메모리에\nmemory pool 형태로 가공해서 접근하는데는 여러가지 노력이 들어.\n가장 크게는 자잘한 메모리는 자잘한 메모리끼리, 큰 메모리는 큰 메모리끼리 격리해서 관리하는 것이지.\n어쨌든, 남은 메모리는 많은데 쥐도새도 모르게 조금 큰 메모리를 할당할 수 없어지는 단편화문제는 벌어지지 않게 할 수 있고,\n할당 해제 비용자체를 OS가 관리해주는 것에 비해 가볍게 줄일 수 있는게 memory pool 의 장점이야.\n엄마 병따주세요 하고 엄마한테 음료수 병 주고 따주면 먹는것 보다 내가 따는게 빠르잖아?\n\n전역( static 영역 )을 크게 잡을지 heap 을 크게 잡을지는 실행파일을 만들때 컴파일러에서 설정할 수 있는데\n\n[ Static ][ Heap ][ Stack ]\n\n과 같은 순서로 데이타 영역에 할당이 돼.\n보통 기본 옵션으론 ( Windows VCC, BCC )\nStack ( 지역변수가 할당되는 공간 )이 가장 작고,\nStatic ( 전역변수가 할당되는 공간 )이 그 다음,\nHeap ( 동적 할당시 사용되는 공간 ) 이 제일 큰 식이야.\n( 운영체제와 컴파일러에 따라 크기와 순서는 다름 )\n\n그러니, 전역 메모리는 메모리 활용도가 떨어진다. 메모리를 많이 차지한다. 라는건 방법론으로 해결될 수 있다는 이야기지.\n오히려 처리 속도를 증가시키기 위해선 적극적으로 써 줘야 되는 경우가 많아.\n\n다음 글에서 더 알아보자.\n","btime":{"$$date":1478741645177},"mtime":{"$$date":1478741645177},"_id":"92Z8sSbB5hM5pDkk"}
{"dirName":"codesafer","subName":"헛소리","fileName":"나를 청와대로 보내라!","fileData":"## 나를 청와대로 보내라\n\n공약 1.\n\n나한테 개소리한 유동들 IP 끝에 끝까지 합법적으로 추적한다.\n이를 위해 헌법 수정할거임.\n\n공약 2.\n\n갤에서 피자돌린거 세금 환급처리 해준다.\n\n공약 3.\n\n노무X란 직업을 없애고, 인터넷 금칙어로 정한다.\n이것도 헌법에 명시.\n그리고 일베는 끝이다.\n","btime":{"$$date":1478746068572},"mtime":{"$$date":1478746068572},"_id":"BUOINREpU6HSfj4M"}
{"dirName":"codesafer","subName":"댓글","fileName":"비논리적 오류 분류","fileData":"### 대개 비논리적인 문제들은 다음과 같은 문제로 해결돼. (해결? 분류돼.)\n\n1. 수치 연산 오류. ( 오버플로 거나 나누기를 잘못했거나... 소수점을 기대하면서 정수를 쓰거나, round-off 거나 )\n2. 이벤트를 정상적으로 생성시켜줄 수 있는 상황이 아닌경우. 즉 리소스 부족 또는 공유할 수 없는 리소스의 혼용 문제.\n3. 재진입 ( re-entrance ) 문제. 이 부분은 절차적으로 실행되지 않는 쓰레드나 타이머 콜백 등에서 발생하지\n4. 포인터 ( 포인터가 쓰기용으로 사용된 모든 부분을 추적해야함 )\n5. 라이브러리 / 컴파일러 오류. ( work around 밖에 답이 없음 )\n6. 메모리릭이나 잘못된 연산으로 개발툴이 미쳤다. ( 재시동 -> 파워 유저 고고싱 )\n    *포인터는 배열 표현도 가능하니까 당연히 배열형태로 사용되는 녀석들의 범위 초과도 검사해야하지.\n7. 케이스를 놓침. ( 논리적 커버리지가 부족했음. 이런건 조건 로그를 찍는 수 밖에 )\n    *객체의 해제도 당연히 메모리를 쓰는거니까 주의\n8. 스택이 터졌음. ( 쥐도 새도 모르게 프로그램이 꺼져버리니 오히려 알기 쉬움 )\n9. 스태틱 영역이 터졌음. ( 마찬가지 )\n10. 힙에 할당이 실패했음. ( 어지간하면 동적 할당 지양하자 )\n11. 생성시점이 모호함. ( 딜레이가 가변적이어서 되다 안되다~ 이런건 생성을 통합 관리해서 해결해야함 )\n12. 정말 아주 정말 희귀하게. 메모리 불량이나 파워불량으로 연산오류가 나오거나 뻗는 경우도 있습니다. ( 특히 똥밟기 좋은 AMD 시스템 )\n    *다른 컴퓨터에서도 문제인지 체크해보는것 밖에 답이 없음.\n","btime":{"$$date":1478745706346},"mtime":{"$$date":1478745772667},"_id":"BdvVBFmViNMf6oeb"}
{"dirName":"codesafer","subName":"코딩 모범에 관한 코멘터리","fileName":"4","fileData":"\n불필요하고 복잡한 것을 넣지 마세요.\n-> 너같으면 넣겠냐? ( 넣는 애들 있음유 )\n-> 최적화 해서 돌아가야 되는 코드에 디버그 코드 도배해서 오작동하게 만드는 애들\n\n구체적인 것이 아닌 추상적인 것에 의존하세요\n-> 재사용성을 높이고, 공통점을 찾아가는데 도움을 줍니다.\n\n직접적인 친구와만 놀고, 친구의 친구와는 놀지마세요.\n-> friend 도배하면 노출이 늘어납니다. 사생활을 보호하세요.\n\nSingletone 패턴을 남용하지 말아주세요.\n-> 싱글턴은 딱 필요한 몇 가지만 만들고, 그 내부에서 자원을 관리하는게 맞습니다.\n-> 아니면 아예 통합 관리자를 따로 만들어야 하쥬.\n\n무리하게 디자인 패턴을 적용하려 하지 말아주세요.\n-> 난 디자인 패턴 따위 공부한적 없다네. 살다보면 패턴 쌓이는데 뭔 패턴\n-> 남이 이거다 저거다 하는거 무분별하게 받아들이지 마세유.\n\n클래스의 역할과 책임에 관해서 생각해주세요.\n-> behavior 와 duty.\n-> 책임이 명확해야 개고생안합니다. 코드는 여러분과 똑같은 생물체 입니다.\n\n1개의 클래스에 너무 많은 일을 주지 않게 설계하세요.\n-> 같은 소리 왜 자꾸 반복해\n\n중재자를 사용해 의존 관계를 단순화하세요.\n-> 라우터가 있으면 편합니다.\n-> 컴파일 속도도 빠르게 할 수 있쥬.\n-> 나중에 객체의 책임 범위가 늘어나거나 수정될 때 방화벽으로 작용해줍니다.\n\n외부와의 인터페이스 부분을 클래스화하세요.\n-> 라지만 DLL 로 뺄때는 클래스가 좆같아 져서\n-> 함수로 클래스를 인터페이스 해야하는 사태가 벌어질때도 있습니다.\n-> 어쨌든 한 번 싸주면 좋습니다.\n\n객체생성도 매우 중요한 역할이랍니다.\n-> 생성자 소멸자 의 역할은 아주 아주 큽니다. 뭐 당연한 소릴 하네.\n\n전용 클래스와 범용 클래스를 명확하게 구분해주세요.\n-> final 같은걸로 더이상 상속 못하게 한다든지,\n-> 헤더에 모두 공개할게 아니라 cpp 안에 숨기든지,\n-> 네이밍으로 너 건들지 마셈 을 표현해두면 좋습니다.\n-> 그만큼 소스코드를 이어받은 사람들이나, 나중에 까먹어버린 내가 볼때 헛손질을 줄일 수 있습니다.\n\n책임을 제대로 이양해 주세요.\n-> 사공이 많으면 배가 산으로 가죠.\n-> 관리포인트는 철저하게 넘겨야 합니다.\n\n클래스의 추상도는 캡슐화에 영향을 줍니다.\n-> 얼마나 일반적인 큰 붓의 범위를 잘 잡았냐가 그림이 삐져나가지 않고,\n-> 작은 붓 손질이 덜가게 만들어 줍니다.\n\n항상 추상도 높은 인터페이스를 어떻게 생성할지 생각해보세요.\n-> 필요하면 붓에 풀을 먹여야 합니다.\n-> 고딕체 같은거 쓸때는 짱이거든요? 매직이나 플러스펜 처럼\n\n추상 인터페이스로 소결합을 유도하세요.\n-> 추상 클래스와 인터페이스를 잘 만드는게 OOP 의 핵심임다. 큰 붓 잘 만들기 니까유.\n\n추상 인터페이스 대신에 std:function을 사용해 보세요.\n-> 가상함수보다 함수포인터가 구현도 활용도 편할때가 많슴다~\n-> 거기다 콜백으로 쓰이면 흐름이 무척 단순화 되는 경우가 많죠.\n-> 이벤트 드리븐!\n\n객체가 처음부터 완전환 상태로 생성되게 해주세요.\n-> 재사용성이 높아지는 비결입니다.\n-> 기능 단위가 분해되어서 여기 저기 자식들 친척들 다 생성되어야 돌아가면 뭐 쓰레기쥬.\n\n실행 순서를 보장할 수 있게 설계해주세요.\n-> 싱글턴 문제와 겹치는 부분도 있는데, 아주 중요합니다.\n-> 모듈별 전역 타입들은 솔직히 프로젝트 구성만 좀 바뀌어도 언제 실행될지 알 수 없으니까유.\n\n생성자와 소멸자로 리소스를 관리해주세요.\n-> 왜 당연한 소릴 하냐. 내가 죽는데 내 주둥아리와 팔이 살아있으면 웃긴거지.\n\n구현 방법을 은폐하는 이름을 붙여 주세요.\n-> 너무 구체적일 필요없이 잘 포괄하는 네이밍이 필요합니다~\n","btime":{"$$date":1478746050785},"mtime":{"$$date":1478746050785},"_id":"FffjnWJNyU6XTtEh"}
{"dirName":"codesafer","subName":"C++ 초보를 위한 강좌","fileName":"06. 상수에 대해 한가지 짚고 넘어가자","fileData":"## 상수에 대해 한가지 짚고 넘어가자\n\n우리가 흔히\n\nint a = 3;\n\n이런 표현을 쓴다면, 우측의 3은 말 그대로 ( literally ) 상수다.\n변하지 않는 값이란 말이지. 고수의 유의어는 아니다. ( 퍽~ )\n\n이런 상수를 literal constant. 리터럴 상수 라고 부른다.\n만약 당신이 literal constant 를 선언하고 싶다면, 변수의 선언 표현앞에 const 를 붙여주면 된다.\n\nconst int c = 3;\n\n처럼 말이다.\n\n\n우리는 ( 크기가 고정인 ) 배열의 크기를 표현하기 위해 리터럴 상수를 쓸 수 있고,\n\nint arr[ 5 ];\n\n처럼 표현했다.\n\n따라서 당연히,\n\nconst int array_size = 5;\nint arr[ array_size ];\n\n도 정상적인 문법이다.\n\n\n하지만 좀 특이한 경우가 있는데, 우리는 변수를 임시로 고정해서 상수 처럼 쓸 수 있다는 것이다.\n\nint input;        // input 은 정수형 변수다.\ncin >> input;     // 키보드 입력을 통해 값을 얻었다.\n\nint arr[ input ];\n\n이건 당연히 컴파일이 안된다. 컴파일러가 상수가 필요합니다! 하겠지.\n\n\n그런데,\n\nconst int array_size = input;\nint arr[ array_size ];\n\n위의 코드처럼 변수를 상수에 보관시켜서 사용하면 어떻게 될까?\n\n\nGCC 에서는 컴파일이 된다.\nVC++ 에서는 컴파일이 되지 않는다.\n\nGCC 가 훨 상수에 대해 유연하다. ( VC++ 은 아직 표준으로 부터 멀고 먼~ )\n하지만, GCC 의 경우에도 template 의 인자로 전달할 때는 임시 고정 상수를 사용할 수 없다.\n심지어 태생이 리터럴 상수라 하더라도, 전달 과정에 변수를 한 번만이라도 거치면 리터럴 상수 취급을 받지 못한다는 것이다.\n( 이건 어쩔 수 없다. 몰래 다른 쓰레드에서 포인터로 전달 과정에 있는 변수를 슥~ 건들면 사실 상수가 아니잖아 )\n\n즉, 나는 상수의 종류를 리터럴 상수와 임시 고정 상수로 정의하되,\nGCC 의 경우 임시 고정 상수를 이용한 배열의 크기 설정이 가능하다라고 해석한다.\n개념적으로 3단계로 분류해도 되겠지만, 아캄의 면도날 원칙을 따르겠다.\n그렇다고 표준 찾아보는것도 따분하니 패스.\n\n컴파일러 마다 사뭇 다를 때, 특정 컴파일러를 대상으로 작성할지,\n보다 많은 컴파일러의 식성을 고려해 작성할지는 여러분의 선택이다.\n\n\n참고.\n\n리러털 상수는, 대표적인 예로 리터럴 문자열 상수 ( \"Hello world\" 처럼 따옴표로 표기한 문자 그대로의 상수 문자열 )\n의 경우와 마찬가지로 실행파일이 실행된 메모리 상의 리터럴 영역에 저장되게 된다.\n이 영역은 읽기 전용이다. ( 몇 몇 과거 컴파일러에선 쓰기가 가능한 경우도 있다. )\n따라서 런타임에 리터럴 저장소인 메모리에 접근해서 문자열을 바꾸려고 시도하면 런타임 오류를 만나게 된다.\n( 물론 컴파일러 최적화에 의해 아예 code 영역에 박혀버리는 경우도 있다 )\n","btime":{"$$date":1478742228719},"mtime":{"$$date":1478744532104},"_id":"HSuqWJgkbKUoKKzU"}
{"dirName":"codesafer","subName":"C++ 에서 전역변수 사용의 득과 실","fileName":"3","fileData":"## C/ C++ 에서 전역변수 사용의 득과 실\n\n\n그 다음 생각해야 할 것은\n1. 초기화 메카니즘\n2. 캐시 효율\n3. Context Switching 비용\n\n이야.\n\nshell 에 의해 프로그램이 실행되면 memory loader 가 실행파일을 읽어서 메모리에 풀어놓는데,\n전역 변수는 자동으로 0으로 초기화 해 줘. ( 물론 크기가 크다면 memory loader 가 0으로 클리어하는 비용 - memset 도 커지지 )\n그리고 초기값이 프로그램에서 할당되어 있었다면 memcpy 로 복사해주지.\n\n만약 0으로 초기화 할 필요가 없는 내용을 전역할당한다면 아주 약간의 손실이 발생한다는거야.\n반면, 0으로 초기화 된걸 가정하고 어느 함수 안에서 그 일부를 재사용하고,\n다시 사용한 만큼만 0으로 다시 지우는 구조를 프로그래밍 한다면,\n코드 몇 줄은 효율적으로 코딩하게 되는 경우도 있긴해.\n\n이것보다 중요한건 캐시 효율인데,\n\n함수의 실행순서가\n\nA->B->C 가 된다든지\nA->C 가 된다든지\nA->D->B->C 가 된다든지\n\n여러 경로를 거쳐 함수 C 가 실행되는 경우를 가정해 보자.\n이때 C 가 사용하게 될 지역변수의 위치는 매 번 바뀌게 돼. ( 스택포인터 - 주소- 의 위치에 따라 )\n즉 캐시 효율이 떨어진다는거야.\n이 경우도 캐싱이 필요없다면 지역변수나 로컬에서 동적 할당/해제 하는 것이 아무 문제 없지.\n\n하지만 전역으로 선언해 놓거나 힙에 할당해 놓은 전역화 메모리는 항상 그 자리( 주소 )에 있게 되지.\n그 말은 캐시 효율이 좋아지겠지?\n\n또 한가지 더 생각해야 할 부분은, DLL 로의 전환 가능성이야.\n\n내가 만든 프로그램이 다른 프로그램에 얹어져서 돌게 될 경우, 전역 초기화 사이클이 변하게 돼.\n이러면 전역이라 하더라도 정적인 특성이 소거되지.\n물론 단 한 번 로딩후 프로그램 종료시까지 변하지 않는다면 상관없지.\nDLL 로딩과 해제가 빈번해져 버리면 단순히 함수 호출처럼 보이겠지?\n\n그리고 추가로 또 한가지,\n임베디드 시스템 처럼 ( 특히 싱글 코어 )\n메모리가 적은 환경에서 쓰레드간 context switching 을 시도해보면\n쓰레드당 할당되어 있는 스택을 비우고 복사하고 하는 비용이 무시못할 정도로 커.\n지역변수를 많이 사용할수록 더 큰 스택이 필요해지고, 그 스택들이 어떻게든 보관, 복구 되어야\n쓰레드간 작업 전환이 된다는거야. ( 이게 다 비용. 세상에 공짜가 어딨음? )\n그런경우, 전역이 훨씬 빠르고 안정적인 동작을 보장하게 되지.\n\n이런 사실을 모르고, 단지\n전역은 쓰면 안돼! 이러면 걍 바보 멍청이임.\n\n여기까지 :)\n두서없는 글 읽느라 수고했엉~\n","btime":{"$$date":1478741875528},"mtime":{"$$date":1478741875528},"_id":"JOSHgaTTMUx7GRGd"}
{"dirName":"codesafer","subName":"뻘소리","fileName":"프로그래머로서 살아남는 가장 중요한 팁","fileData":"### 프로그래머로서 살아남는 가장 중요한 팁\n\n1. 갈증날 때 물 바로 바로 마셔라.\n   커피나 음료수는 안좋다. 특히 믹스 커피.\n   ( 프림은 음독하는거라 생각해라 )\n2. 어떤 일이 있어도 하루 30분은 걸어라.\n\n화장실 가기 귀찮다고 물 안마시고,\n자리에서 일어나기 귀찮다고 안움직이다가\n뇌졸중 오네.\n\n가끔씩 머리에 스파크 튀다가\n작년 말부터 왼팔, 왼손 엄지 저림 증상이 오더니\n지난달 부터 어깨냉증으로 바꼈다.\n\n이대로면 2년 안에 중풍걸릴듯.\n건강을 회복하기 위해 특단의 조치가 필요한 시점이다.\n완전한 회복은 힘들고 지연시키는 정도에 그칠지 모르지만...\n중풍 걸리더라도 프로그래밍 할 수 있으면 좋을텐데\n\n건강할 때는 모르지.\n심혈관질환 때문인지\n하루가 다르게 머리가 티미해진다.\n\n즐겁게 알차게 살아라.\n","btime":{"$$date":1478745827209},"mtime":{"$$date":1478745827209},"_id":"LYykx7ZlqvnGny1d"}
{"dirName":"codesafer","subName":"개념글","fileName":"index를 0부터냐 1부터냐","fileData":"## index를 0부터 시작하느냐 1부터 시작하느냐\n\npascal 은 기본적으로 1부터 시작하고 있고, 배열 인덱스를 재배치 할 수도 있다 (시작을 음수로도 지정 가능)\nC의 포인터를 이용하면 역시 음수 index를 사용할 수는 있지.\n\nex)\n```\n#define RADIUS 1000\n#define RAD2DIA_DREG 1\n#define DIAMETER (RADIUS * 2 + RAD2DIA_DREG)\nint pixelsInSin[DIAMETER];\nint* centerInPixels = pixelsInSin + RADIUS;\n```\n위의 예는 픽셀의 단위에서 중앙이 픽셀과 픽셀 사이에 위치하는 애매함을 해결하기 위해\n지름이 반지름 * 2 + 1 이 되는 아름답지 않은 상황을 반영한 것.\n이 코드에서 우리는 centerInPixels[-RADIUS] 부터 centerInPixels[RADIUS] 까지 접근 할 수 있다.\nsin, cos 같은류의 -1 ~ +1 범위 연산을 수행하기 적합한 코드지.\n\n자연수의 정의는 0을 포함하기도 하고(집합론) 포함하지 않기도 한다.\n집합론에서 0의 정의는 null 이고, (의미적으로 nothing 이 아니다. no something 이다. 우주는 무의 공간이 아니거든)\n1의 정의는 {null} // something\n인데 반해\n2의 정의는 {{null}, {null}} 또는 (수론으로 연결됨)\n{null, {null}} (집합론, 경우의 수를 센 정보량적 표현)\n로 표현되는 것과 같은 이치다.\n\n이런 문제는 min to max 의 범위 문제로 이어지는데,\n정규화 시킨 0 ~ 1 의 범위가 scaling 과 같은 transform 에 가장 아름답지만,\n주기성의 out of bound 를 clamp 할 수 있는 나머지 연산(%) 은 range - 1 의 결과를 얻기에\nrand() 류의 함수 역시 범위 - 1 의 max 를 갖는다.\n\n조금 말이 어렵지?\n\n우리는 우리의 문제와 해결방법을 다양한 용도에 사용될 수 있게 하기 위해 정규화를 해야한다.\n가령 20~50 범위의 입력을 10 ~ 100 범위의 출력으로 바꾸고 싶다는 것 과같은 transform 을 자주 구현하게 되는데\n이럴 때, 네 가지 일반적 단계를 거치게 된다.\n\n1. min을 0점으로 이동 (min의 normalize)\n2. max를 1로 바꿈 (max의 normalize)\n3. 스케일링 (size 의 reflection)\n4. 결과점(원점)으로 이동 (position 의 reflection)\n\n위의 단계대로 20~50 을 10~100 으로 바꾸어 보면\n\n1. 입력 - 20 을 해서 0~30 범위를 얻는다\n2. 30으로 나누어 0~1 범위를 얻는다\n3. 90으로 곱하여 0~90 범위를 얻는다\n4. +10 해서 10~100 범위를 얻는다\n\n로 전개 되는 것이다.\n\n이 예는 특별한게 아니다.\nRGB 의 각 색상 콤포넌트의 범위를 0~255 로 정의하는 시스템도 있고 0~1로 정의하는 시스템도 있다.\n0~1로 정규화해서 표현하지 않고 MAX를 0.9 나 0.99 0.999 로 표현한다면 얼마나 바보같을지 생각해 봐라. 우습지만 그런 시스템 흔하다.\n만약 누군가 0~255 의 RGB 색상 공간을 0~65535 의 sRGB 색상공간이나 0~15 의 색상공간으로 변환하는 일을 빈번하게 수행한다고 가정하자.\n정규화를 하지 않으면 변환 전의 format 을 사용해 나올 수 있는 경우의 수를 모두 구현해야 한다.\noutputComponent = inputComponent / inputMax * outputMax\n하지만 입력(inputComponent)을 0~1로 변환한 다음이라면,\noutputComponent = inputComponent * outputMax\n이렇게 간단히 outputMax의 곱셈만 수행하면 되고 변환 전의 format 을 기억할 필요가 없다.\n\n여기서 내가 말하고자 하는것은 한가지다.\nmin을 1로 하여 자연수 max 를 표현하면 max == range 가 되어 우선 깔끔해 보이지만,\n0도 1도 무척 중요하고 정규화라는 편의성을 제공해주기 때문에 Max 를 Range 로 두는건 뒷단에서의 노가다를 감수해야하는거다.\n\n자기 코드 안에 이곳은 수론 저곳은 집합론의 표현으로 구현해두면 헷갈릴 수 밖에 없겠지.\n/*\n대부분의 시스템에서 max는 range 일 수 없다.\ndreg 는 서로 다른 시스템간의 변환에서 사람의 인식을 돕기위해서나 위치를 존재하게 하기 위한 필요악이다.\n우리는 흔히 dreg 문제를 해결하기 위해 반올림이나 버림 따위의 애매한 선택을 하기도 하고,\n그 애매한 선택은 프로젝트 종료까지 너를 따라다닐거다. 어쩌면 영영 아쉬움으로 남을 수도 있고.\nmin 이 1이 되는 시스템이 많을 것 같냐?\n하지만 min을 0으로 두면 어느방향으로든 나아가기 쉽다.\n정규화를 통해 max를 1로 두면 아름답다. 그말은 많은 곳에 유용하게 쓰인다는거다.\n1보다 작은 소숫점으로 나누면 1보다 큰 자연수를 곱하는 효과니까 -1. ~ +1 의 영역이 hot spot 이란거다.\n삼각함수의 좁은각 특성이나 테일러 급수를 이용한 최적화에 이용하더라도 유리한 공간임엔 틀림없다.\n*/\n\n두 줄 요약.\n위의 4가지 step 에서 1번이라도 수행하지 않을 수 있게 해주기 위해 0부터 시작하는 index 가 여러모로 유용하다고 생각.\n어디까지나 개인 취향의 문제로 보이지만, 시작을 저렇게 해두지 않으면 뒤에서 늘어나는 코드와 수고는 자기 책임이다\n","btime":{"$$date":1478742583479},"mtime":{"$$date":1478745646523},"_id":"LajL08ZKqJTq5Meb"}
{"dirName":"codesafer","subName":"개념글","fileName":"가장 기본적인 조건제어문은 do while 입니다","fileData":"## 가장 기본적인 조건제어문은 do while 입니다\n\n가령\nint a = 0;\ndo a++; while( a < 10 );\n\n위 같은 코드는 실제로는 다음과 같이 번역됩니다.\n어셈블리 코드로 적으면 낯설테니 그냥 pseudo code로.\n\na <- 0;\nloop:\n    a <- a + 1\n    if( a < 10 )\n        goto loop;\n\n만약\n\nint a;\nfor( a = 0; a < 10; ++a );\n\n와 같은 코드를 작성하면,\n컴파일러가 최적화 하지 않는 경우 다음과 같은 코드로 번역됩니다.\n\na <- 0;\nloop:\n    if ( a >= 10 )\n        goto next;\n    a <- a + 1\n    goto loop;\nnext:\n\n차이를 아시겠어요?\ndo ~ while 은 3줄짜리 코드. ( 루프의 반복회수가 N 일 때 complexity 3N )\nfor는 4줄짜리가 됩니다. ( 루프의 반복회수가 N 일때 complexity 4N, 즉 25% 성능차이 )\n\n하지만 컴파일러는 시작 초기화값 상수 0 이 10보다 작다는걸 알기 때문에\n최적화를 걸면 for 문을 do ~ while 로 해석해서\n세 줄짜리 코드를 만들어 줍니다.\n\ndo-while 을 안쓰다뇨.\n루프에 들어갈때 조건을 판단하는거랑,\n일단 실행하고 루프를 빠져나갈때 조건을 판단하는 구조는\n명령어 1개 만큼의 최적화 영향을 받게 됩니다.\n```cpp\n// str 이 char* 타입일때\nwhile( *str++ ); 과\nwhile( *str ) str++;\n\n의 차이점도 아셔야 합니다.\n\n전자는 null 문자를 만나고 나서 빠져나올때 하나 더 str 을 증가시키게 됩니다.\n후자는 null 문자를 만난 위치에 포인터가 멈춰서게 되죠.\n저걸 pseudo 코드로 나열하면, 다시 명령어 하나가 루프안에 더 있고 없고의 차이가 됩니다.\n컴파일 되고 나면 *str++ 을 사용한쪽이 반복문 안에서의 명령어가 하나 적게 되기에\n\nsize_t strlen( const char* str )\n{\n    char* ptr = (char*)str;\n    while( *ptr++ );\n    return ptr - str - 1;\n}\n\n이게\n\nwhile( *ptr ) ptr++; 를 사용해서\nreturn ptr - str; 하는 코드보다 효율적인 코드가 됩니다.\n\nrequest 를 받아 위의 두 예도 pseudo code 를 작성합니다.\n단, 이경우 if 문 형식과 어셈블리 코드가 조금 달라지니\n최대한 x86 instruction 에 맞춰 비교구문을 test 라고 하겠습니다.\n\n1. while( *ptr++ ); 의 경우\n\nloop:\n    result_flag << test( *ptr, 0 );\n    ptr <- ptr + 1;\n    if( result_flag.contains( not_zero ) ) goto loop;\n\n\n2. while( *ptr ) ptr++; 의 경우\n\nloop:\n    result_flag << test( *ptr, 0 );\n    if( result_flag.contains( zero ) ) goto next;\n    ptr <- ptr + 1;\n    goto loop;\nnext:\n```\n위와같이 3줄 명령어 루프와 4줄 명령어 루프가 됩니다.\n","btime":{"$$date":1478744794080},"mtime":{"$$date":1478744794080},"_id":"MIZfKApAzE0KCRuo"}
{"dirName":"codesafer","subName":"C++ 초보를 위한 강좌","fileName":"10. 작은 콘솔 프레임워크","fileData":"## 작은 콘솔 프레임워크\n\n오늘은 여러분께 작은 선물을 준비했다.\n\n낯선 표현들이 나오지만 다음강에서 설명할테니 잠시만 어리둥절 하자.\n``` cpp\n//==============================================================================================\n#pragma warning(disable: 4996)  // _CRT_SECURE_NO_WARNINGS\n#include \"stdafx.h\"\n#include <array>\n#include <stdio.h>\n#include <conio.h>              // _kbhit\n#include <Windows.h>\n//------------------------------------------------------------------------------------------------\n\n#define CRE                     // constructor mark\n\nusing   u8                      = unsigned  char;\nusing   u16                     = unsigned  short;\nusing   u32                     = unsigned  int;\nusing   uu                      = std::size_t;\n\n//------------------------------------------------------------------------------------------------\n\nconstexpr   auto                make_color16( u8  l, u8  r, u8  g, u8  b )\n{\n    return  u8( l << 3 | r << 2 | g << 1 | b );\n}\n\nenum    class                   C4 : u8\n{\n    //                      +  R  G  B\n    black   = make_color16( 0, 0, 0, 0 ),\n    navy    = make_color16( 0, 0, 0, 1 ),\n    green   = make_color16( 0, 0, 1, 0 ),\n    teal    = make_color16( 0, 0, 1, 1 ),\n    maroon  = make_color16( 0, 1, 0, 0 ),\n    purple  = make_color16( 0, 1, 0, 1 ),\n    olive   = make_color16( 0, 1, 1, 0 ),\n    silver  = make_color16( 0, 1, 1, 1 ),\n    gray    = make_color16( 1, 0, 0, 0 ),\n    blue    = make_color16( 1, 0, 0, 1 ),\n    lime    = make_color16( 1, 0, 1, 0 ),\n    aqua    = make_color16( 1, 0, 1, 1 ),\n    red     = make_color16( 1, 1, 0, 0 ),\n    fuchsia = make_color16( 1, 1, 0, 1 ),\n    yellow  = make_color16( 1, 1, 1, 0 ),\n    white   = make_color16( 1, 1, 1, 1 ),\n};\n\nconstexpr   auto                operator/( const C4 fore, const C4 back )\n{\n    return  u8( static_cast< u8 >( back ) << 4 | static_cast< u8 >( fore ) );\n};\n//------------------------------------------------------------------------------------------------\n\nclass                           CONSOLE\n{\n    struct                      LETTER\n    {\n        u8                      color;\n        char                    tex;\n    };\n\n    static  const   int         width   = 80;\n    static  const   int         height  = 25;\n    static  const   int         size    = width * height;\n    using                       MATRIX  = LETTER (&)[ height ][ width ];\n\n    char                        buffer_[ 8192 ];\n    std::array< LETTER, size >  buffer;\n    MATRIX&                     screen  = (MATRIX&)buffer;\n    HANDLE                      handle;\n\n    void                        go( const short x, const short y ) const\n    {\n        SetConsoleCursorPosition( handle, { x, y } );\n    }\n\n    void                        color( const u8 c ) const\n    {\n        SetConsoleTextAttribute( handle, c );\n    }\n\n    void                        resize( int w, int h )\n    {\n        COORD       coord { w, h };\n        SetConsoleScreenBufferSize( handle, coord );\n        SMALL_RECT  rect = { 0,0, w - 1, h - 1 };\n        SetConsoleWindowInfo( handle, TRUE, &rect );\n    }\n\npublic:\n\n    CRE                         CONSOLE( bool full_screen = false )\n    :   handle( GetStdHandle( STD_OUTPUT_HANDLE ) )\n    {\n        setvbuf( stdout, (char*)&buffer_, _IOFBF, sizeof buffer_ );\n        cursor( false );\n        if( full_screen )\n            SetConsoleDisplayMode( handle, CONSOLE_FULLSCREEN_MODE, NULL );\n        clear();\n    }\n\n    void                        cursor( const bool show ) const\n    {\n        CONSOLE_CURSOR_INFO info = { 1, show };\n        SetConsoleCursorInfo( handle, &info );\n    }\n\n    void                        flush( const int s = size - 1 ) const\n    {\n        resize( width, height );\n        go( 0, 0 );\n        u8  old_color;\n        color( old_color = buffer[ 0 ].color );\n        putchar( buffer[ 0 ].tex );\n        for( int i = 1; i < s; ++i )\n        {\n            if( old_color != buffer[ i ].color )\n            {\n                fflush( stdout );\n                color( old_color = buffer[ i ].color );\n            }\n            putchar( buffer[ i ].tex );\n        }\n        fflush( stdout );\n        go( 0, 0 );\n    }\n\n    void                        clear()\n    {\n        buffer.fill( { text_color, ' ' } );\n        flush( size );\n    }\n\n    u8                          text_color      = 0x07;\n    u8                          number_color    = 0x07;\n    u8                          number_size     = 11;\n    bool                        right_alignment = true;\n\n    void                        put( const u32 x, const u32 y, const LETTER tex )\n    {\n        screen[ y ][ x ] = tex;\n    }\n\n    void                        put( const u32 x, const u32 y, const char c )\n    {\n        put( x, y, { text_color, c } );\n    }\n\n    auto                        puts( const u32 x, const u32 y, const char* str )\n    {\n        u32 i;\n        for( i = 0; str[ i ]; ++i )\n            put( x + i, y, { text_color, str[ i ] } );\n        return  x + i;\n    }\n\n    template< uu SIZE >\n    auto                        puts( const u32 x, const u32 y, const char* str,\n                                      const u8( &colors )[ SIZE ], const int offset = 0 )\n    {\n        u32 i;\n        for( i = 0; str[ i ]; ++i )\n            put( x + i, y, { colors[ ( i + offset ) % SIZE ], str[ i ] } );\n        return  x + i;\n    }\n\n    auto                        to_string( const int n ) const\n    {\n        static  char    numstr[ 14 ];\n        int* c = (int*)numstr;\n        c[ 2 ] = c[ 1 ] = c[ 0 ] = 0x20202020;\n        bool    neg     = false;\n        u32     u       = n;\n        if( n < 0 ) neg = true, u = -n;\n        char*   p       = numstr + ( sizeof numstr - 1 );\n        char*   end     = p - number_size;\n        do *--p = u % 10 + '0', u /= 10; while( u );\n        if( neg ) *--p  = '-';\n        if( !right_alignment )\n            return  p;\n        return  end;\n    }\n\n    auto                        text_number( const u32 x, const u32 y,\n                                             const char* s, const int n )\n    {\n        return  puts( puts( x, y, s ), y, to_string( n ) );\n    }                                        \n};\n//------------------------------------------------------------------------------------------------\n\nint main()\n{\n    CONSOLE stage;\n    u8 color_set1[] = { 15, 7, 8 };\n    stage.puts( 2, 1, \"Hello teX\", color_set1 );\n    u8 color_set2[] = { (u8)C4::red, (u8)C4::white, (u8)C4::white, (u8)C4::white };\n\n    stage.puts( 2, 3, \"Codesafer's C++ programming guide\", color_set2 );\n\n    int i = 0;\n    while( !_kbhit() )\n    {\n        stage.puts( 2, 5, \"Codesafer's C++ programming guide\", color_set2, i++ );\n        stage.flush();\n    }\n    getchar();\n\n    int frames = 0;\n    while( !_kbhit() )\n    {\n        for( int i = (int)C4::blue; i < 256; i += 16 )\n        {\n            stage.text_color = i;\n            stage.clear();\n            stage.text_number( 30, 12, \"Hello teX\", ++frames );\n            stage.flush();\n        }\n    }\n    getchar();\n    return  0;\n}\n//==============================================================================================\n```\n안타깝게도 Windows API 를 사용했기 때문에 VC++ 에서 밖에 컴파일되지 않는다.\n\n내가 C++14 문법에 재미를 들인고로 Visual Studio 2015 이상을 권한다.\n\n모든 학문이 그렇듯, 프로그래밍은 무조건 재밌게 공부해야 한다.\n\n실행하면 다음과 같은 텍스트 애니메이션 화면이 나온다.\n","btime":{"$$date":1478742295502},"mtime":{"$$date":1478742295502},"_id":"MYELnI0QxE6Z1WT9"}
{"dirName":"codesafer","subName":"알아보자","fileName":"졸자","fileData":"프갤 신입\n\n따라서 데이터가 많지 않음.\n\n어떤 프갤의 대표 악플러는 자신의 무식함을 드러내며\n졸다의 청유문 형태로 해석하던데,\n발음을 적어보면 '졸짜' 임.\n\n\n억측. ( 이번 억측들은 좀 확률이 낮음 -> 내 세대 기준 프로파일을 사용한게 좀 됨 )\n\n1.  자주 정리하는 타입이라기 보다 덜 어지럽히려고 하는 타입일듯. ( 책 쌓아놓는거 제외 )\n2.  아버지는 똑똑하고 강하신 분이라 자상하기 보다\n    책임을 분명히하는 선에서 집안을 통제하는 타입일듯. ( 간섭 < 위엄 )\n3.  어머니가 의외로 형 같은 느낌일 수 있음.\n4.  맞벌이실 가능성 높음.\n5.  무리의 비위를 맞춰주기보다 옳다고 생각하는 이야기는 하는 타입이라\n    친구는 정의롭고, 적은 어리석었을듯.\n6.  하지만 실친은 많지 않을 타입. 고고하다.\n    오랜친구는 극히 적고, 최근, 그리고 앞으로 만날 친구들이 평생갈듯.\n7.  살짝 통통한 타입일듯. 향후 심혈관질환 유의.\n\n\n관찰.\n\n1.  착하고 착하며 착하다.\n2.  맥락을 잘 짚는다.\n3.  그래서 B급 문화에서도 충분히 그루브를 탄다. ( 문화에 편식을 덜한다 )\n4.  관심분야가 넓어 숙고할 시간이 부족한 탓에 약간 이른 단정을 한다.\n5.  누가 무슨 뻘소릴 하든 취할것과 버릴것 보류할 것을 구별해서 가진다.\n6.  성격이 보살이다.\n7.  표현이 조근조근하다. 그다지 과장하지 않는다.\n8.  박식하다.\n9.  또래위주의 B급 문화 커뮤니티 활동 특성인지 맞춤법을 꽤 많이 틀린다.\n10. 당당한 오덕이다.\n11. 캐릭터의 특성을 쉽게 파악하고 잘 몰입한다.\n12. 언론, 교육쪽에 자질이 있음. 예술쪽은 그닥.\n    문과인듯한 이과고 이과인듯한 문과다.\n13. 돈낭비하지 않는 타입. 소소히 즐긴다.\n14. 자기 책임은 꼼꼼히 다하는 스타일이라 어느조직에서든 밥값은 한다.\n    인간관계로 너무 스트레스만 주지 않으면.\n15. 올바른 가치의 권위를 인정한다.\n16. 자립심이 있다. 타인에게 많은 도움을 바라지 않는다.","btime":{"$$date":1478745882722},"mtime":{"$$date":1478745882722},"_id":"Mk1Ev1I3fRHWgZtZ"}
{"dirName":"codesafer","subName":"개념글","fileName":"쉬운 언어로부터 고급 언어 프로그래밍을 시작하기는걸 권한다.","fileData":"### 쉬운 언어로부터 ( 고급 언어 ) 프로그래밍을 시작하는걸 권한다.\n\n쉬운 언어와 간편하고 폭넓은 프레임웍.\n\n이게 있어야 프로그래밍으로 할 수 있는게 많아지고 재미있음.\n\n고급언어는 학습 범위의 큰 틀을 이해하는데 도움을 주고,\n\n개념을 쉽게 잡게 해 줌.\n\n로우레벨로 내려가는건 프로그래밍의 재미를 느낀 후\n\n성능과 자립성, 디테일에 욕심이 생길때 시작하면 좋아.\n\n그러니까\n\n고급 -> 저급 -> 고급 -> 저급 -> 고급\n\n으로 가는게 맞다.\n\n1. 개념을 익히기 위해 고급\n2. 하부구조와 원리, 최적화의 힌트들을 알기 위해 저급\n3. 다양한 개념과, 성능에 효과적으로 컴파일될 고급 언어의 표현을 익히기 위해 고급\n4. 세세한 이형 시스템들의 예외적 차이, 하드웨어 자체를 구현( HDL 이용 )하기 위해, 병렬처리 등을 위해 저급\n5. 생산성과 안정성, 제품의 수명을 높이기 위해 고급\n","btime":{"$$date":1478745304810},"mtime":{"$$date":1478745304810},"_id":"NO5dUmwGfUHMVDDa"}
{"dirName":"codesafer","subName":"코딩 모범에 관한 코멘터리","fileName":"2","fileData":"STL 알고리즘 함수를 활용해 주세요.\n-> 지난 강좌 글에서 설명했습니다.\n\n검색 반복문을 분리해주세요.\n-> 재사용될 수 있는 여지가 큽니다.\n-> 한 번에 결과를 내 놓는 함수인지, 순차나 2진 탐색을 통해 결론을 내는 함수인지\n-> 함수명을 통해 분명히 구별해주는게 무분별한 사용을 통한 성능저하를 막을 수 있습니다.\n-> find, search, seek, query, indexof 등의 네이밍으로 구별.\n\n반복문 내의 처리는 최소한으로 만들어 주세요.\n-> 당연하긴 한데, 성능을 위한 루프 언롤링은 별개 문제.\n-> 반복문 안에서 변화하는 값이 아닌, 반복문 밖에서 결정될 수 있는 모든 값들은\n-> 반복문 안에서 계산시켜서는 안됩니다.\n\n반목분 내부에서는 1개의 처리만 수행하세요.\n-> 요건 좀 위에꺼랑 중언 부언에 오버임.\n\n람다식을 사용해서 반복문을 일반화하세요.\n-> 람다식을 사용한다는건 지역화, 익명화의 장점을 가짐과 동시에,\n-> 이름을 가진 변수에 대입해 두고 다른곳에서 사용할 수 있는 반대의 의미도 있습니다.\n-> 일반화를 통해 파라메터를 정리하게 되는데, 그 과정에서 성능을 높일수 있는 여지가 다시 발생하게 됩니다.\n-> 하지만 반대로 값이 계산되어 조건 안에 들어가게 되기 때문에, short circuit 효율이 떨어지는,\n-> 인자로 사용된 값들이 미리 모두 계산되어야 하는 단점도 있습니다.\n-> 알고 쓸 노릇입니다.\n\ncase 내부는 함수화해주세요.\n-> 코드가 길어지면 좋을게 없습니다. 30줄 이내로 맞춰주세요.\n-> case 를 탄다는건 상태 변화에 대응한다는 것인데,\n-> 요구사항 변화에 따라 매번 코드 블럭을 붙였다 내렸다 하는것도 미개한 방법입니다.\n\n부정확한 상태를 assert로 확인해주세요.\n-> 이것도 중언 부언\n\n상태에 따른 분기는 다형성을 사용해야 하는 신호에요.\n-> 상태를 상수로 정의할 수 있는지 타입으로 정의할 수 있는지 고민하고,\n-> 템플릿의 파라메터로 넣어버리것이 코드를 정리하는 방법입니다.\n\n1개의 함수에는 1개의 역할만 주세요\n-> 당연. 그래야 재사용성이 높아집니다.\n-> 대신 당연하게도 상위 함수에선 여러개의 단위 함수를 부르는 구조면 됩니다.\n-> 즉 역할이 두꺼워지는 상위함수는 있을 수 있지만,\n-> 그 내부는 함수 호출 네이밍으로 간결히 정리되어 있어야 한다는거죠.\n\n단순한 함수일수록 재사용하기 좋아요\n-> 절대적입니다. 위와 같은 말이죠.\n\n복잡한 복합 조건은 피해주세요.\n-> 앞서 다 이야기 한 내용.\n\n자연어처럼 읽을 수 있게 코드를 작성하세요.\n-> 역시 설명함.\n\n조건 분기 블록 내부는 함수화해야 하는 후보랍니다.\n-> 모든 블럭은 함수, 클래스, namespace 의 후보입니다.\n\n1개의 반복문에는 1개의 함수만 사용해주세요.\n-> 좀 과도해서 멍청한 이야기. 병렬화 때 약간의 이점은 가져갈 수 있습니다.\n\n반복문 블록 내부는 함수화 후보랍니다.\n-> 또 중언 부언.\n\n데이터 변환 부분은 함수화해주세요.\n-> 자주 쓰입니다.\n\n데이터 확인 부분은 함수화해주세요.\n-> evaluation 과 validation, verification test 는 간과하기 쉽지만,\n-> 굉장히 중요한 부분입니다. 잘 정리해 두셔야 합니다.\n\n배열 랜덤 접근 부분을 함수화해주세요.\n-> 이미 정리된 이야기 입니다.\n\n취약한 기본 자료형 배열을 사용하지 말아 주세요.\n-> 구조체나 클래스로 한 번 싸주란 이야깁니다.\n-> 그게 코드가 더 구조적이되고 관리포인트를 줄일 수 있습니다.\n-> 명시적이기도 하구요.\n\n주석으로 말하지 말고 함수로 말하세요.\n-> 프로그래머는 코드로 말해야 합니다 암요~\n\n매개 변수가 너무 많다면 함수를 분할하라는 신호랍니다.\n-> MS API 코드들을 보면 얼마나 개떡같은지 알 수 있습니다.\n-> 덕분에 코드 재사용성이 거의 없어지지요.\n-> 뭔 당장 필요치도 않은 구조체를 얼마나 원하는지. 181818\n\n매개 변수가 너무 많다면 클래스화하라는 신호랍니다.\n-> 동일 매개 변수가 여러 함수에 반복될때 클래스화 하라는 신호입니다.\n","btime":{"$$date":1478746039003},"mtime":{"$$date":1478746039003},"_id":"NSgvyQy5tiy86nE8"}
{"dirName":"codesafer","subName":"C++ 초보를 위한 강좌","fileName":"04. 추상화, 일반화와 특수화","fileData":"## 추상화, 일반화와 특수화\n\n우리는 흔히 추상화라는 말을 듣게 된다.\n어릴땐 미술에서 듣다가 프로그래밍 세계에서 만나게 되면 약간의 모호감을 느낄 수 있을듯.\n\n추상이란 말은, ab + straction\nab 는 약, 대략의 의미고\nextraction 이 추출의 의미, tract 가 범주의 의미인 '계' 이니\n말 그대로 뽑을 추, 형태 상.\n개략적인 형태를 뽑아내는걸 말한다.\n\n그말은 구체적인 부분을 배제하고, 보다 포괄적인 의미, 큰 붓으로 그릴 이미지를 뽑는단 말이다.\n추상없이 모든 디테일을 기억하려 들다간 우리의 머리는 곧 포화상태에 이르게 된다.\n\n다른말로, 추상을 통해 개략적으로 표현된 데이타를 컴퓨터에게 연산시키는 편이 성능을 높이는데도 짱이다.\n필요한 개괄적 특징을 뽑아내는것,\n즉 의미로운 특징을 뽑아내는것,\n즉 시그널이라 불릴 기준을 정해서 사물에서 뽑아내어 정보량으로 표현하는것.\n이것이 컴퓨팅 이론에서 말하는 추상이다.\n\n쉬운 예를 들어보자.\n갤러그 스러운 슈팅 게임을 만들려고 보니 남은 비행기의 댓수를 표현하고 싶다.\n혹은 비행기의 남은 에너지를 표현하고 싶을수도 있고,\n잠수함의 남은 배수량을 ( 배수량 한계까지 물이 차면 꼬로록 ) 표현하고 싶다면,\n\n가장 기본적으로는 정수 하나면 충분하겠다. ( 여기서 깨알같이 등장하는 상수. 훗 )\nint air_plane  = 5;\nint sub_marine = 5; // displacement\n\n이것이 추상이다.\n\n여기서 비행기가 한 대 죽은 경우는 air_plane-- 로 정의된다.\n배수량이 감소하는 것도 마찬가지.\n\n마찬가지로 비행기를 한 대 획득한 경우는 air_plane++ 로 정의된다.\n배수량이 증가하는 것도 마찬가지.\n\n이건 일반적인 흐름이 된다.\n\n그렇지만 특수한 흐름이 필요하고, 그것은 바로 죽음이다.\n아이러니하게도 모든 생물은 죽음이란 상태를 통해 정의가 완성된다.\n\n비행기 한 대의 죽음과, 게임의 끝.\n배수량의 감소와, 잠수함의 침몰을 완전히 정의하기 위해 다음과 같은 표현이 필요하다는 것이다.\nif( --air_plane == 0 ) game_over();\n\n이런 추상의 과정에 있어서, 일반화와 특수화라는 개념을 포함시키면,\n추상은 보다 실제적이지 않은, 개념적 영역에 속하게 되고,\n일반화는 추상의 논리적 형태와 가까운 실제화,\n특수화는 일반화의 형태에서 부족한 부분을 표현한 실제화가 된다.\n\n말이 어렵지?\n\n일반화는 큰 붓, 특수화는 작은 붓이다.\n\n산을 그리는데 삼각형으로 충분하면 그건 쉬운 산이고 아주 쉽게 일반화 된다.\n그런데 나무가 보이는 산 ( 근경 )과 보이지 않는 산으로 구별해야 할 필요가 생기면,\n앞서 삼각형으로 정의한 산에 대해 보완이 필요하다. 그게 특수화의 개념이지.\n\ntemplate 의 경우에도 추상, 일반화와 특수화가 적용되고\nclass 의 경우에도 추상과 일반, 특수의 개념이 적용된다.\n\n우리가 만약, 반복적인 흐름 속에 if 문 한 줄을 통해 예외적 처리를 해야하는 경우를 만난다면,\n반복적 흐름은 큰 붓, 즉 일반화, if 문 한 줄의 예외 또한 특수화로 정의 되는 것이다.\n\n이 개념은 OOP 전반, TMP 전반, 실상 모든 프로그래밍 영역에서 활용되는 개념으로,\n정리해주고 싶었다.\n","btime":{"$$date":1478742190963},"mtime":{"$$date":1478744524740},"_id":"O5qZos0AMDV495hM"}
{"dirName":"codesafer","subName":"알아보자","fileName":"사랑돋긔","fileData":"프갤 중견\n\n사실 그다지 글이나 코드를 맞댄 상대가 아니라 어떤 기준에서 봐야할지 망설여졌다.\n그래서 추측 ( 사실은 프로파일 기반의 억측 ) 과 관찰을 적당히 섞어볼까 한다.\n\n20대 중반\n\n억측.\n1.  기질적인 면에 있어 겨울이나 이른봄에 태어난 사람의 성향을 갖는다.\n2.  왕성한 활동성, 적극적 대인관계는 키가 크지 않은편을 암시한다.\n    ( 사람 많이 만나고 다닌다는 이야긴 아니다 )\n3.  밤( 심야 )에 주로 활동하는 사람들은 음기가 많은편이고,\n    피부가 희지 않을 가능성이 높다.\n\n관찰\n1.  예술가적 기질과 사업가적 기질이 공존. 미적 감각이 있다.\n2.  논리력을 갖고 있음. 프로그래머 테크를 타도 평타는 칠듯. 수학은 싫어할 타입.\n3.  감수성이 풍부함.\n4.  누군가 자기를 공격하면 강하게 반발한다. 파이터 기질이 있음.\n5.  흥분했을때와 평상시의 온도차가 큼. 조울증이 보임 ( 식생활 패턴으로 바꿀 수 있음 ).\n6.  즉흥성과 투기성이 있음.\n7.  계획을 잘 꾸민다.\n8.  연출을 잘 한다.\n9.  동세 파악과 교정에 재능이 있다.\n10. 줄건 주고 받을건 받고, 가치를 갖는 문제에 적극적으로 공을 들인다.\n11. 애정 결핍의 긍정적 방향성을 띤다. -> 선택된 타인에게 애정을 주고싶어 한다.\n12. 권위에 관심이 없다.\n13. 당장 돈을 추구하지만 돈 자체에 관심이 없고 그 것으로 할 수 있는 가치에 관심이 많다.\n14. 일에 자신감이 있다. 하지만 자신감을 표출한 뒤로는 엄청 고민하고 노력하는 타입.\n15. 자기 판단이 강해보이지만 실상 타인의 평가에 민감하다.\n\n전체적으로 보면, 현실감각을 잃지 않은 예술적 완벽주의자.\n하지만 제대로 된 그릇과 도구들을 준비하지 못해 낭비하는게 많다.","btime":{"$$date":1478745856337},"mtime":{"$$date":1478745856337},"_id":"OyzEpEfrACTeTHm1"}
{"dirName":"codesafer","subName":"개념글","fileName":"어제 누가 질문한 문제 pow 쓰면 안되는 이유.","fileData":"1. double 의 표현범위는 가수부 정확도를 무시하고 10의 308승 정도다.\n   당연히 문제는 100의 100만승 의 범위를 이야기 하니까. double 을 이용하는 pow 따위 노답.\n\n2. 각 진법의 곱셈은 제일 아랫자리의 순환으로 수렴된다. 문제의 특수성을 이해하는게 중요.\n\n즉,\npow 는 일반해\n표현범위는 일반론의 한계\n끝자리 순환은 특수해를 위한 특징\n\n대략\n```\n#include <iostream>\n\n#define rigid                   constexpr\n#define countof( arr )          ( sizeof arr / sizeof *arr )\n\nusing   uu                      = std::size_t;\n\nusing   namespace   std;\n\nconst   uu      radix = 10; // 진법\n\ninline  auto    count_of_suffixes( const uu a ) // 순환 길이 측정 O( log radix )\n{\n    uu  ret = a;\n    uu  len = 0;\n\n    do  ret = ret * a % radix, len++; while( ret != a );\n\n    return  len;\n}\n\ninline  auto suffix_of_pow( const uu a, const uu b ) // a ^ b 표현의 각 진법 마지막 자리 구하기 O( 1 )\n{\n    const   uu  suffix_a = a % radix;\n    const   uu  count = ( b - 1 ) % count_of_suffixes( suffix_a );\n\n    uu  ret = suffix_a;\n    for( uu i = 0; i < count; ++i )\n        ret = ret * suffix_a % radix;\n\n    return  ret ? ret : radix;\n}\n\n대략 이런식으로 설명되는데,\n이 순환 패턴을 상수로 작성하면 O( 1 ) 이 된다.\n\nrigid   uu  suffixes0[] = { 0, };\nrigid   uu  suffixes1[] = { 1, };\nrigid   uu  suffixes2[] = { 2, 4, 8, 6, };\nrigid   uu  suffixes3[] = { 3, 9, 7, 1, };\nrigid   uu  suffixes4[] = { 4, 6, };\n\nrigid   uu  suffixes5[] = { 5, };\nrigid   uu  suffixes6[] = { 6, };\nrigid   uu  suffixes7[] = { 7, 9, 3, 1, };\nrigid   uu  suffixes8[] = { 8, 4, 2, 6, };\nrigid   uu  suffixes9[] = { 9, 1, };\n\n이렇게 10진법 지수표현의 각 밑수 기준 순환테이블을 만들고,\n\ntemplate< class T >\nstruct                          ARRAY\n{\n    const   T*                  items;\n    const   uu                  size;\n    const   T&                  operator[]( const uu index ) const\n    {\n        return items[ index % size ];\n    }\n};\n\n이런식으로 낱개의 서로 다른 길이의 배열을 하나로 묶어줄 wrapper 를 만든 뒤,\n\n#define itm_( n )               { suffixes##n, countof( suffixes##n ), }\nrigid ARRAY< uu > suffixes_list[] =\n{\n    itm_(0), itm_(1), itm_(2), itm_(3), itm_(4),\n    itm_(5), itm_(6), itm_(7), itm_(8), itm_(9),\n};\n#undef  itm_\n\n이렇게 하나의 배열로 묶어주면 되지.\n\ninline  auto    suffix_of_pow( const uu a, const uu b )\n{\n    auto    ret = suffixes_list[ a % radix ][ b - 1 ];\n    return  ret ? ret : radix;\n}\n```\n이렇게 불러주면 되는것. 완전한 O( 1 ) 이지?\n\n그런데, 순환 배열 상수를 저렇게 암산하는건 아름다운 케이스가 아니지.\n다른 진법에서 일일이 계산하기도 귀찮고 말야.\n\n그러니,\n```\ntemplate< uu... ns >\nstruct                          seq // template variadic parameter 를 수열로 처리하는 구조체 \n{\n    static  rigid   auto        size()\n    {\n     return  sizeof...( ns );\n    }\n\n    static  rigid   auto        to_array()\n    {\n        return  std::array< uu, size() > { ns... };\n    }\n};\n\ntemplate< uu n, uu radix = 10 >\nstruct                          suffix // 자동으로 끝자리 순환 배열을 만드는 구조체\n{\n    template< uu s, uu... ns >\n    struct                      make : make< s * n % radix, ns..., s % radix > {};\n\n    template< uu... ns >\n    struct                      make< n, ns... > : seq< n, ns... > {};\n\n    static  rigid   auto        to_array()\n    {\n        return  make< n * n >::to_array();\n    }\n};\n```\n실제로 10개에 대해 만들자.\n```\n#define itm_( n )               { (const uu*)&suffixes##n, suffixes##n.size(), }\nrigid ARRAY< uu > suffixes_list[] =\n{\n    itm_(0), itm_(1), itm_(2), itm_(3), itm_(4),\n    itm_(5), itm_(6), itm_(7), itm_(8), itm_(9),\n};\n#undef  itm_\n```\n끝~.\n\n모든 경험은 재사용될 수 있게 코드로 옮겨져야 한다. ( 짬날때 일반화 하자. 그게 니 미래다 )","btime":{"$$date":1478745325114},"mtime":{"$$date":1478745672538},"_id":"QIoKYO6GDfhkTuB4"}
{"dirName":"codesafer","subName":"코딩 모범에 관한 코멘터리","fileName":"3","fileData":"컴파일러의 최적화 기능을 활용하세요.\n-> 코드를 무리하게 최적화하지 말라는 이야깁니다.\n-> 반대로, 환경변수나 #define, constexpr 처럼 순수 상수 조건은\n-> 시스템 환경에 맞춰 기각되니 if 문 같은걸로 표현해도 컴파일시 걸러져서 좋습니다.\n-> 최적화를 위해 상수 기각조건 코드는 적극적으로 활용하란 소립니다.\n-> 대신 디버깅 모드에선 모조리 코드에 포함되어 코드 캐시 효율이 떨어지긴 합니다.\n\n재사용만이 함수화의 장점이 아니랍니다.\n-> 의미의 직관적 전달이 가져오는 효율은 모든 개발사이클에서 빛을 발합니다.\n-> 관리 포인트를 한 군데 집중시켜주는 효과도 있습니다.\n\n기본 자료형을 최소한으로 만들어 주세요.\n-> 기본 자료형이란 보다 더 추상적인 자료형이란 겁니다.\n-> 그 말은 의미가 모호하단 소리죠.\n-> 하지만 별다른 기능 추가 꺼리도 없는데 미리 손품 파는건 귀찮으니 패스.\n-> 기본 자료형은 반드시 클래스나 구조체로 바꿔야만 하는건 아닙니다.\n-> getter 와 setter 형태의 함수로도 정의할 수 있는 것이죠.\n-> 즉 기본자료형의 역할은 자료형 + 기본 연산자( 함수적 기능 ) 이 포함된 개념입니다.\n-> 자료형도 함수화든 객체화든 마음껏 변화시킬 수 있습니다.\n-> 추가적으로 만약 우리가 8비트 데이타를 이미지의 샘플로 주로 활용하는 경우라면,\n-> char 이렇게 선언해 쓰는것 보다 using PIXEL = char; 처럼 사용하는게,\n-> 그걸 가져다 쓴 함수와 객체 안에서 명시적인 의미전달을 하게 됩니다.\n\n컨테이너 조작을 위한 전용 클래스를 만들어 사용하세요.\n-> 자주 쓰이는데 맨날 코드로 늘어뜨려 다니느니 컨테이너는 항상 구조화 하는게 낫습니다.\n\n변수를 클래스화해서 의도를 명확하게 전달해주세요.\n-> 다 했던 이야기.\n\n변수를 클래스화해서 제한을 해주세요.\n-> 제한이 필요하다면 물론.\n-> 우리는 해당 변수의 전체 표현영역( dynamic range )을 필요로하지 않는 경우가 많습니다.\n-> 오류 검사나, clamper 가 필요할 수 있죠.\n\n부분을 작게 만들면 전체가 작아져요.\n-> 최소공배수를 구할 때 사용하는 소인수분해랑 같은 이치입니다. ( GCD 구하면 땡이지만 )\n-> 보통의 코드는 걍 공배수죠. 소인수분해를 해 보면 중복이 제거되고 최소공배수라는\n-> 멋진 코드가 만들어집니다.\n\ngetter와 setter를 되도록 사용하지 마세요.\n-> 이건 반은 맞고 반은 틀린 이야기\n-> 클래스 내부가 뻥튀기되어 너저분해지는 단점이 있고,\n-> getter 와 setter 를 연산자 오버로딩 등\n-> 더 편한 방법으로 관리할 수 있는 경우가 있습니다.\n-> 무분별한 사용을 하지 말라는 이야깁니다.\n\n부모 자식 관계라도 private를 사용해주세요.\n-> 은닉화는 모든 문제를 심플해보이게 해 줍니다. 숨길 수 있는건 최대한 숨겨야죠.\n\n클래스의 멤버 변수는 최소한으로 만들어주세요.\n-> 어떤 항목의 열거도 8개를 넘어가면 가독성이 떨어집니다.\n-> 그 말은 필요시 클래스를 나누라는 이야기가 됩니다.\n-> 상속도 좋은 예죠. 함수의 파라메터 이야기랑 같은 이야기.\n\n소결합 클래스로 설계해주세요.\n-> 결합점이 클수록 재사용성은 떨어집니다. 또한 수정이 아주 힘들어지고,\n-> 독립작업이 힘들어 집니다.\n-> 최소접점을 유지해주세요.\n\n상속보다는 이양을 우선해주세요\n-> 이거 뭐 국어가 힘드네 이양? is 냐 has 냐 이야기 하는거겠죠?\n-> 상속의 구조를 끌고가는게 유리한 경우와 단순히 멤버로 가지고\n-> 가져다 쓰는게 유리한 경우가 있습니다.\n-> 경험이 꽤 필요합니다. 상속은 그만큼 컨트롤이 힘들기 때문에\n-> 집에 일꾼 필요하다고 애새끼 주렁 주렁 낳는건 피곤한 일입니다. 특히 호적, 족보 관리.\n-> 필요할 때 고용하세요!\n\n상속과 추상 인터페이스 구현을 구별해주세요.\n-> 언어마다 좀 다른 이야기인데, 약간 Java 관점?\n-> 물론 구별은 해야쥬. 그래서 순수 가상함수가 존재하는것 아니겠음?\n\n하나의 클래스에 하나의 책임만 맡겨주세요.\n-> 중언부언\n\n변하지 않는 부분과 변하는 부분을 구분해서 설계해주세요.\n-> 정말 중요함유~ 개방과 폐쇄 원칙의 기본.\n","btime":{"$$date":1478746044221},"mtime":{"$$date":1478746044221},"_id":"SjzQhyZ1yr9Xlvy8"}
{"dirName":"codesafer","subName":"개념글","fileName":"소스코드를 잘 읽는건 뭐니뭐니 해도 컴파일러다.","fileData":"## 소스코드를 잘 읽는건 뭐니뭐니 해도 컴파일러다.\n\n컴파일러는 실수하지 않는다.\n컴파일러에 버그가 있다면 그건 제작자의 실수지.\n\n즉 주어진 룰에 따라 구문을 해석할 뿐이다.\n\n컴파일러는 컴퓨터의 역사에서 아주 초기에 등장했다.\nFTP고 OS고 마찬가지.\n덧셈밖에 모르는 바보 전자장치에게 가르칠수 있는건 한계가 있기 때문에,\n아주 기본적인 부분들에서 효과적인 녀석들만 먼저 도입된거다.\n그 말은 짜달아 복잡할게 없다는 거고.\n\n복잡한건 소스코드를 읽는 사람 대가리일 뿐.\n\n코드에는 스타일이 있고,\n사람이 말하는데도 스타일이 있다.\n\n같은 말을해도 인내심이 없으면 짜증날 정도로 정리되지 않은 나열을 하는 사람들이 있고,\n어려운 이야기도 잘 정리해서 이야기 하는 사람이 있다.\n\n이때 필요한것은?\n호흡과 템포, 용어의 정리.\n즉, 코드의 끊어읽기와 변수명 / 함수명의 정리가 중요하단거다.\n\n난 처음 남의 소스코드를 읽을 때, 띄어쓰기와 개행을 내가 읽기 좋은 스타일로 정리하면서\n변수명도 조정하며 읽었다.\n\n그게 익숙해지면 개략적인 형태만 봐도 '아 이샛기 왜 이걸 이따위로 짰어?' 하게 되지만,\n니가 지금 남의 코드를 읽어야 한다는건,\n니가 아직 파악하지 못한 분야를 선행자로 부터 전수 받는다는걸 의미하는거지.\n\n왜 필요한지에 대해 알고, 어떻게 하면 되는지 알면 남의 코드를 볼 필요가 없다.\n걍 니가 짤 수 있음.\n\n그렇다면, 니가 그걸 못할때, 남의 코드를 보는 시점에서\n이게 왜 필요한지와, 어떻게 필요한 요소들을 채워갔는지 지켜보면 되겠지.\n\n조건반복문의 흐름이 안잡히나?\n테이블에 그려라.\nfor 문의 반복자 들을 가로 세로 등으로 배치하고,\n각 반복자가 변할때 상태나 결과값이 어떻게 반영되는지 표에 그려라.\n\n그게 익숙해지면 종이가 없어도 머리에 표가 그려진다.\n\n사람은 납득하지 못했을때 상상을 하고,\n상상이 곧 발전의 원동력이자 노이즈의 소스이기도 하다.\n\n남의 코드를 볼땐, 악보를 외울때 처럼 각색없이 달달 외어야 한다.\n그리고 니가 연주할 땐, 상상력을 폭발시켜야 된다.\n\n코드를 해독하는데 왜? 이렇게? 정도에 상상력을 발휘하더라도.\n남의 코드는 있는 그대로 받아들여라.\n그게 컴파일러가 하는 짓이다.\n\n몇 가지 연산에 완전히 익숙해지는데는 많은 시간이 걸리지 않는다.\n그게 익숙하지 않다는건,\n니가 억수로 안짜봤거나, 대충 이해하고 넘어갔다는 의미다.\n","btime":{"$$date":1478745296957},"mtime":{"$$date":1478745296957},"_id":"WJHO9ym68o9U3Ryr"}
{"dirName":"codesafer","subName":"뻘소리","fileName":"내가보는 재능의 정의","fileData":"## 내가 보는 재능의 정의\n1.  기억력\n    미끌어지면 영원히 오를 수 없다.\n    거북이라도 열에 하나씩은 암기해야 함.\n    물론 열에 열 외우는 애들이 더 빠름.\n    하지만 장담코 그런 애들은 토끼라 낮잠잠. = 나\n\n2.  자부심\n    자만심, 자긍심이랑 비슷한 스펙트럼이지만 의미가 조금 다름.\n    단순한 자기 긍정은 의미 없음. 그건 오히려 태만으로 치닫지.\n    뼈를 깎으면서도 쾌감을 느끼는 것. 스스로를 독려하는 것.\n    지지배처럼 징징거리느라 시간을 허비하지 않는 것.\n    이런 사람에게 공부란 표현보단 연구란 표현이 어울림.\n\n3.  경쟁심\n    최종 보스는 자신.\n\n4.  구체를 향한 관찰력\n5.  추상에 대한 사고력\n\n    특징을 잡아내는 동체 시력.\n    미시적 차이를 보는 눈.\n    거시적 공통점을 보는 눈.\n\n    보편적인 사람들이 이거랑 저거랑 틀려 라고 할 때,\n    아니, 이것과 저것은 다르지만, 이건 같잖아.\n\n    다른 사람들이 이건 똑같네 할 때,\n    아니, 이건 이러이러하게 미묘하게 다른데?\n\n    할 수 있는 구별력.\n    근데 그게 궤변이나 양비론과 다른건,\n    더 큰 일반화와 특수화 라는\n    철학적 정리라는 가치를 향해 있어야함.\n\n6.  인내력\n    뜬구름 잡는 이야기에서도 가치가 보이면 맥락을 짚어내려 포기하지 않는 사고 맷집.\n\n7.  산술능력\n    크게 중요하진 않지만 아주 편리한 도구\n    보통 사람들은 이런게 재능이라고 생각하겠지만 사실 비중이 크지 않음.\n\n8.  뇌내 시각화 능력\n    공간지각력과 유사.\n    개념이 공간속에 다양한 모양으로 렌더링 될 수 있어야 함.\n    아주 정교하게.\n    산술 능력의 상위호환 재능이라고 볼 수 있음.\n\n9.  기획력\n    공부, 연구, 자기계발은 재미있는 그릇을 준비해야 잘 담긴다.\n\n10. 올바른 가치를 바라보는 건전성\n    대사량이 활발한 뱀은 독을 많이 만들 뿐.\n","btime":{"$$date":1478745795954},"mtime":{"$$date":1478745795954},"_id":"WUhnkai4Q3Co22JG"}
{"dirName":"codesafer","subName":"개념글","fileName":"getter와 setter를 쓰는 이유","fileData":"## getter, setter 를 쓰는이유 첨언\n\n1. wrapper 는 분산된 사용처들을 위한\n   수정해야 할 포인트를 한 곳으로 집중해 준다.\n   일종의 gateway 다.\n\n2. lvalue 로써의 접근과 rvalue 로써의 접근을\n   추적가능케 해 준다.\n   실행단계별 사용빈도를 추적할 수도 있다.\n   쓰기 혹은 읽기 위주로 주로 사용되는 자료구조에 대해\n   추적해서 별도 최적화할 수 있는 힌트를 제공한다.\n\n3. 어떤 값의 변경을 컨트롤 할 수 있다.\n   즉, setter를 쓰는 이상 [변경]은 더이상 존재하지 않는다.\n   [변경 시도]가 존재할 뿐이다.\n   이는 범위한정 등에서 유용하다.\n   on_change event handler\n   set_bound( min_constraints, max_constraints );\n   와 같은 interface 를 활성화 할 수 있게 해 준다.\n\n4. 어떤 값의 변경 결과를 시각화 할 수 있다.\n   set_color( CL_RED );\n   를 호출했을 때 해당 컨트롤의 색깔이 변해버리게 말이다.\n   데이타의 변화와 시각화가 연동되는 엑셀과 같은 사용환경 구현이 가능하다.\n\n5. getter는 실 메모리 사용량을 감소시킬 수 있다.\n   left, top, right, bottom, width, height 와 같은 속성을 예로 들자면,\n   right, bottom 혹은 width, height 멤버 변수만 갖고 있으면\n   반대편을 계산가능 하다.\n   auto get_right() { return  left + width; }\n   auto get_width() { return  right - left; }\n   처럼 말이다.\n   어떤 값을 결정하는데 사용되는 복수개의 요인에 대해 통일된 접근을 제공한다.\n   변경이 잦지만 정작 변경된 결과를 참조하는 회수가 적을 경우 성능도 높여준다.\n\n6. property 확장 문법을 지원할 경우\n   직관적으로 lvalue 또는 rvalue 의 사용이 가능하다.\n   object.color = CL_RED; 가\n   실제로는 object.set_color( CL_RED ); 가 호출되게 된다.\n   cout << object.color; 역시\n   실제로는 object.get_color(); 가 호출되게 된다.\n\n낮잠 자다 일어나서 생각나는대로 끼적여봄.\n","btime":{"$$date":1478742572680},"mtime":{"$$date":1478742572680},"_id":"XPAZ2Z48R7ZFITZV"}
{"dirName":"codesafer","subName":"알아보자","fileName":"아둔이는요.","fileData":"프갤 중견\n\n20대 중반\n\n관찰\n1.  조증이 있다.\n    다른 말로 스테미너가 좋다.\n2.  장난꾸러기다.\n    가끔 돌직구를 던지는듯 보일지 모르지만 내면에 대한 솔직함이 아니라,\n    단지 도발적인 장난이다.\n    결계( sandbox )를 다룰 줄 안다는 소리.\n3.  자존심이 강하다. 자기 현시욕이 강하다.\n    따라서 내성적인 부분도 크지만 자신의 의지로 행동방침을 재정의한다.\n4.  병적으로 일단 한 번 꼰다. 각색한단 말.\n    이건 다양한 각도로 세상을 바라보는 습관이기도 하지만, 산만함이기도 하다.\n5.  타인에 대해 조심스럽고, 시험한다. 하지만 결론도 조심스럽게 낸다.\n    사실 결론 내는일에 조차 산만하다.\n6.  직선적인 비평을 두려워한다.\n   \t자신의 속내가 들키지 않을까 전전긍긍한다.\n7.  역할극을 잘한다. 연기력이 있다. 능청스럽다.\n8.  자기 격려, 가치부여가 잘된다.\n9.  고민하기 보다 저지른다.\n10. 남에게 치대고, 귀찮게 굴고, 멋대로 한다.\n    애정결핍의 한 가지 양태.\n11. 대신 그 멋대로가 멋있는 모습을 보여주는 것을 목표로 하고 있다.\n12. 한마디로 돈을 꾸어가서 보석을 돌려 주는 타입. ( 갚는것도 제멋대로다 )\n13. 문제는 '지' 가 보석인줄 안다.\n    ( 남이 그렇게 평가하는건 문제가 되지 않는다. 나랑 같은 병이다 )\n14. 하루 하루가 이벤트다.\n15. 착한 사람이다.\n16. 적극적이지만 끝마무리에 약하다. 그래서 성취감을 위해 쉬운레벨을 맴돈다.\n17. 대기만성형. 점점 학문에 흥미를 느끼기 시작한다.\n18. 하지만 독학이 외로워서 사람들 앞에 잘난척하느라 시간을 많이 쓸듯.\n19. 간접 경험보다 체험을 좋아한다.\n    비약은 하지만 추상적인 개념을 다루는데 서툴다.\n20. 20대까지는 소년이다가 30대에 들어 그의 붙임성이 리더십에 녹아날듯.\n    30대 중반 이후엔 자신의 사업을 가지게 된다.\n21. 하나 배우는게 빠르지 않지만, 일단 익힌건 쉽게 미끄러지지 않는다.\n    하나를 가르치면 똥을 20개는 쌀 녀석이다.\n22. 남들이 흔히 보지못하는 또 하나의 그릇이 있는 사람.\n\n","btime":{"$$date":1478745866841},"mtime":{"$$date":1478745866841},"_id":"Ylxt65PSzZOBrC9b"}
{"dirName":"AdunDocs","subName":"About","fileName":"3","fileData":"## C/ C++ 에서 전역변수 사용의 득과 실\n\n\n그 다음 생각해야 할 것은\n1. 초기화 메카니즘\n2. 캐시 효율\n3. Context Switching 비용\n\n이야.\n\nshell 에 의해 프로그램이 실행되면 memory loader 가 실행파일을 읽어서 메모리에 풀어놓는데,\n전역 변수는 자동으로 0으로 초기화 해 줘. ( 물론 크기가 크다면 memory loader 가 0으로 클리어하는 비용 - memset 도 커지지 )\n그리고 초기값이 프로그램에서 할당되어 있었다면 memcpy 로 복사해주지.\n\n만약 0으로 초기화 할 필요가 없는 내용을 전역할당한다면 아주 약간의 손실이 발생한다는거야.\n반면, 0으로 초기화 된걸 가정하고 어느 함수 안에서 그 일부를 재사용하고,\n다시 사용한 만큼만 0으로 다시 지우는 구조를 프로그래밍 한다면,\n코드 몇 줄은 효율적으로 코딩하게 되는 경우도 있긴해.\n\n이것보다 중요한건 캐시 효율인데,\n\n함수의 실행순서가\n\nA->B->C 가 된다든지\nA->C 가 된다든지\nA->D->B->C 가 된다든지\n\n여러 경로를 거쳐 함수 C 가 실행되는 경우를 가정해 보자.\n이때 C 가 사용하게 될 지역변수의 위치는 매 번 바뀌게 돼. ( 스택포인터 - 주소- 의 위치에 따라 )\n즉 캐시 효율이 떨어진다는거야.\n이 경우도 캐싱이 필요없다면 지역변수나 로컬에서 동적 할당/해제 하는 것이 아무 문제 없지.\n\n하지만 전역으로 선언해 놓거나 힙에 할당해 놓은 전역화 메모리는 항상 그 자리( 주소 )에 있게 되지.\n그 말은 캐시 효율이 좋아지겠지?\n\n또 한가지 더 생각해야 할 부분은, DLL 로의 전환 가능성이야.\n\n내가 만든 프로그램이 다른 프로그램에 얹어져서 돌게 될 경우, 전역 초기화 사이클이 변하게 돼.\n이러면 전역이라 하더라도 정적인 특성이 소거되지.\n물론 단 한 번 로딩후 프로그램 종료시까지 변하지 않는다면 상관없지.\nDLL 로딩과 해제가 빈번해져 버리면 단순히 함수 호출처럼 보이겠지?\n\n그리고 추가로 또 한가지,\n임베디드 시스템 처럼 ( 특히 싱글 코어 )\n메모리가 적은 환경에서 쓰레드간 context switching 을 시도해보면\n쓰레드당 할당되어 있는 스택을 비우고 복사하고 하는 비용이 무시못할 정도로 커.\n지역변수를 많이 사용할수록 더 큰 스택이 필요해지고, 그 스택들이 어떻게든 보관, 복구 되어야\n쓰레드간 작업 전환이 된다는거야. ( 이게 다 비용. 세상에 공짜가 어딨음? )\n그런경우, 전역이 훨씬 빠르고 안정적인 동작을 보장하게 되지.\n\n이런 사실을 모르고, 단지\n전역은 쓰면 안돼! 이러면 걍 바보 멍청이임.\n\n여기까지 :)\n두서없는 글 읽느라 수고했엉~\n","btime":{"$$date":1478741658128},"mtime":{"$$date":1478741658128},"_id":"ZoU67cfzmiaPJiQg"}
{"dirName":"codesafer","subName":"C++ 에서 전역변수 사용의 득과 실","fileName":"1","fileData":"## C/ C++ 에서 전역변수 사용의 득과 실\n\n1. 전역 변수는 프로그램의 실행 시점에 생성되어서 종료시점에 해제됨.\n2. 지역 변수는 함수의 실행 시점에 생성되어서 함수의 종료시점에 해제됨.\n3. static 으로 선언된 지역 변수 ( 정적 변수 ) 는 전역 변수와 같음.\n다만 이름이 노출되는 범위만 지역에 한정됨.\n\n그말은, 전역 변수는 사이클 전용트랙 같은 경기장이고,\n지역변수는 걍 운동장이란거야. 니들이 공연을 하든 축구를 하든, 육상대회를 하든\n그때 그때 원하는 용도로 메모리라는 자원을 사용가능하다는거지.\n전역변수는 용도 변경이 힘든 메모리 라는거고.\n\n하지만, 전역으로 선언한 자원의 용도 변경이 완전히 불가능한 것은 아니야.\nC++ 은 포인터를 사용할 수 있고, 포인터의 캐스팅이 그걸 가능하게 해주지.\n\n그래서 넓은 자원을 전역으로 할당해 놓고 memory pool 로 활용할 경우는\n변수 단위로도 구조체 / 클래스 단위로도 접근할 수 있어서 용도 변경이 가능해.\n\n본질적으로 보면, 램은 유한자원이고,\n컴퓨터가 부팅된 후 실행시간에 램을 늘이고 줄일 방법이 존재하지 않기 때문에,\n사실상 정적 메모리고, byte 단위로 주소 지정가능한 전역메모리라고 볼수 있어.\n\n그걸 메모리 풀처럼 할당 해제해주는 기능을 OS 가 대신하고 있을 뿐이지.\nmalloc 과 free, new 와 delete 와 같은 동적할당 메카니즘을 통해서 말야.\n\n하지만 전역변수가 동적 할당 메카니즘에 비해 유리한 경우가 있어.\n그건 바로 memory fragmentation - 메모리 단편화 - 로 부터 자유롭다는거지.\n\n만약 누군가가\n[A][B][A][B]\n이렇게 4개의 블럭을 동적 할당해서 사용하다가\nB 들을 다 해제 했다면\n[A][_][A][_]\n가 되어서 두 블럭이 사용가능해져.\n하지만 이때, 블럭 두개짜리 를 한 번에 할당하려고 하면 할당이 안돼.\n동적 할당은 논리적으로 연속한 메모리만 허용하거든.\n( 주소 선형성을 만족하는 = 주소가 인접한 메모리 끼리 )\n\n이걸 메모리 단편화라고 해.\n\n이 문제를 해결하기 위해서 memory compaction 을 구현하는 경우가 Java 나 C# 의\nGarbage collector 야.\n[A][_][A][_] 를\n[A][A][_][_] 가 되게 옮겨 주는거지.\n","btime":{"$$date":1478744477734},"mtime":{"$$date":1478744477734},"_id":"aDrys6i0D8PnwfSA"}
{"dirName":"codesafer","subName":"개념글","fileName":"은닉화와 투명성의 가치","fileData":"## 은닉화와 투명성의 가치\n\n### 은닉화 (encapsulation)\n\n예전에 디자인 회사에 있을 때, 그 디자인 회사의 사장 형이 말해 줬었지.\n데셍과 정밀묘사는 껌인데 색채론에 약하다는 내 말에,\n\n\"정말 최고의 색채론은 Black & White 다.\"\n\"모든 색과 가장 잘 어울리는 색은 무채색이다.\"\n\n그 이후 나는 인터페이스에 3톤 이상을 사용하는것을 무척 절제하게 되었다.\n신호처리 알고리즘에 있어서도 마찬가지지. 2진화라는건 중요한 부분을 드러내는데 그 가치가 있다.\n판화 작품으로 부터 타들어가는 듯한 강렬한 인상을 느껴본적 있는가?\n나는 뱀파이어물 만화 hellsing 이란 작품의 코믹스판 그림체에서 '판화 같다' 는 느낌을 받은적 있다.\n강렬한 흑백사진같은 정중동의 느낌을 잘 살린 만화는 아쯔시 카미조의 to-y 였지.\n\n\n### 투명성 (clarity, transparency)\n\nJava 코드는 C++ 코드에 비해 많은 것을 숨기고 있다.\n그 말은 로우레벨 자유도가 떨어진다는 의미와 함께, 하이레벨 자유도가 높아진다는 의미를 갖는다.\n\n로우레벨 접근성이 좋다는 것은, 당연히 경제성을 극대화 할 수 있다는 이야기가 된다.\nCISC 와 RISC의 장단점을 떠올려 보라.\n손으로 한땀 한땀 최적화한 RISC 프로세서는 renewal 비용이 비싸지만,\n새로운 요구사항들이 쏟아지지 않는 한 양산화에서 최적의 경제성을 보장한다.\n\n초기 개발시점에서 python 으로 작업하고, 어느정도 완성도를 가졌을 때\n보다 native 한 언어로 porting 하는 것은 두 마리 토끼를 잡을 수 있는 방법일 것이다.\n하드웨어 칩셋 개발에서도, 프로토타이핑과 소규모 시장 테스트는 FPGA로,\nmassive한 수준의 양산화가 필요하면 로직 디자인을 ASIC 하는 것이 유효한 방법인 것 처럼 말야.\n\n시장은 틈새에서 발생하는것이니만큼, 어느쪽이 유용하다 단정할 순 없다.\n둘 다 아는 것이 필요하다.\n\n\nExposing issues of developer's Interface\n\nprivate, protected, public, published 와 같은 노출과 접근 권한 관계의 이야기에 있어서,\n투명성은 안정성을 해치고, 은닉화는 개발의 시간적 최소비용을 증가시킨다.\n하지만, 프로젝트의 볼륨이 커지면, 안정성이 더 큰 가치로 대두되는 것이지.\n\n영어 사전이 있으면 단어장은 왜 가지고 다니는가? 둘 다 필요하기 때문이다.\nosX 에는 exposer 가 있다.\n단어 하나만 쳐 넣으면 필요한 정보들을 노출해 준다.\n단어장의 장점을 사전에 도입한 경우랄까?\n\nabstraction, summarize 없는 transparency는 두 말할 여지없이 독(toxic)이다.\nabstraction 과 encapsulation 은 조금 닮았지만 전혀 다르다.\n\n진정한 명료성은(clarity)\ntransparency, abstraction, summary, encapsulation 의 적절한 배합으로 얻어질 수 있다.\n","btime":{"$$date":1478745360247},"mtime":{"$$date":1478745360247},"_id":"ab9wQMpdKexW7m1S"}
{"dirName":"codesafer","subName":"개념글","fileName":"코드세이퍼의 그림 실력.jpg","fileData":"## 코드세이퍼의 그림 실력.jpg\n![](/upload/1130_코드세이퍼.jpg)\n\n고1 수업시간에 공부안하고 그렸다고 합니다.","btime":{"$$date":1478745571034},"mtime":{"$$date":1478745577609},"_id":"agRY7ku8G8CdXe4j"}
{"dirName":"codesafer","subName":"C++ 초보를 위한 강좌","fileName":"05. 까막눈 뜨기는 이름이 어딘지 아는것 부터","fileData":"## 하지만 API는 지저분 하다?\n\n우리네 틀딱 선배님들이 젊은 시절에 열심히 만들어둔 운영체제의 틀은\n수많은 수정요구에 의해서 타협하고 수정되고 버려지고 대체되면서 시궁창이 되어버렸다.\n\n물론 정리가 잘 된 운영체제의 개발환경도 있고,\nUnix 를 바탕으로 만들어진 ( 사실상 운영체제의 표준격인 ),\nPOSIX 정의를 잘 따르는 인터페이스들도 있다.\n\n하지만 우리가 주로 사용하는 Windows 의 API 란건 쓰레기도 이런 쓰레기가 없을 정도다.\n그걸 조금 편해 보겠다고 객체같지도 않은 MFC 로 싸버렸으나 노답인건 매한가지,\n상대적으로 진보적인 프레임웍이었던 VCL 의 개발 책임자를 사 와서 .Net 을 만들었으나\n.Net 환경 프로그래밍 또한 그렇게 매력적이진 않다. ( 물론 MFC 보다 나은건 인정 )\n\n우리가 가장 큰 데스크탑 시장의 개발환경을 과감히 포기할 용기가 없다면,\n이 그지 발싸개 같은 운영체제를 우리는 써야 하고 배워야한다.\n아~~주 잘못 만들어져 있다는걸 깨닫는데 오랜시간이 걸리지 않겠지만 말이다.\n다행스럽게도 당신이 좋은 프레임웍을 선택한다면,\n그지 발싸개랑 대화하기 위해 그지 발싸개를 이해하는데 필요한 시간을 줄일 수 있다.\n\n여기서 여러분은 선택해야 한다.\n\n1. 여러 운영체제용으로 포팅이된 프레임웍을 이용해 조금 더 상위 레벨에서 프로그래밍 할 것인가?\n   그를 통해 여러분은 다른 운영체제에서도 쉽게 돌아갈 수 있는 프로그램을 만들 수 있다.\n\n2. 그지 발싸개 ( Windows API )를 공부해서 \"난 빌게이츠를 사랑해요\"를 외칠 것인가?\n   미안하지만 이 공부는 최소화 하는게 낫다.\n   윈도우 디바이스 드라이버나 자유자재로 만들면서 먹고 살 틈새를 기대하는게 아니라면.\n   ( 그나마도 꽤 비싼 드라이버 인증 비용을 물어야 최신 Windows 운영체제에서 실행해 줄 것이다 )\n\n3. .Net 기반환경에서 개발할 것인가?\n   CLI 라는 인터페이스가 있으나 이건 C++ 이 아니라고 보는게 맞다.\n   그럴거면 차라리 C# 을 써라. MS 도 Windows 전용을 포기한것 같던데.\n\n4. 윈도우즈 버려!\n   축하한다. 너 금수저.\n\n다시한번 말하지만 Windows 는 쓰레기다.\n하지만 제법 두꺼운 콘크리트 기반을 깔고 산다면 지하가 쓰레기 매립지인줄 모르고 살 수 있다.\n가끔 우물 파는 사람들은 경악하겠지만.\n\n그러니 정신건강을 생각한다면, Windows API 를 대체할 무언가를 선택하는게 좋다.\n컴파일 시간을 부스팅 시켜주는 boost 도 좋은 예이고,\npoco 같은 프레임웍을 쓸 수도 있다.\n\nGUI 가 필요하다면 OpenGL 기반의 여러 프레임웍들이 준비되어 있다.\n크로노스 그룹에서 지원하는 OpenXXX 프로젝트들은\n여러분이 그 기반위에서 작성한 프로그램들이 여러 운영체제에서 돌아갈것을 약속해준다.\n\n조금은 더 편하고 조금 더 진보적인 프레임웍을 선택하라는 이야기다.\nMS 너무 까서 MS 빠들에게 미안하다만,\n까일만 하다.\n\n앞으로 이 강좌 씨리즈가 어떻게 흘러갈지 나도 모르지만,\n일단은 OOP 와 TMP 위주로 진행할 것 같다.\n그게 좀 더 범용성을 띤다고 생각되어서 말이다.\n\n초보자들이 사용하기에 편리한 프레임웍들이 있다면 여러 사람들이 추천해줬으면 한다.\n","btime":{"$$date":1478742102700},"mtime":{"$$date":1478744528176},"_id":"dZykMOVt38ZCa6BZ"}
{"dirName":"codesafer","subName":"개념글","fileName":"추상화, 은닉화, 캡슐화, 다형성, 상속성, 클래싱","fileData":"## 추상화, 은닉화, 캡슐화, 다형성, 상속성, 클래싱\n\n\n### 연산자재정의(operator overriding)\n연산자는(operator) 궁극적으로 함수와(function) 같은, 자료형 혹은 객체를 다루기 위한 방법일(method) 뿐이다.\n그래서 operator overloading 이란, (본질적으론 overriding 에 가깝다. overloading 은 실상 넌센스)\n연산 기호를 함수이름과 동일시하는게 목적일 뿐이다.\n오버로딩이란(과적 - 기존의 의미에 추가로 의미를 더하다) 단어를 연산자에 사용하기에는 무리가 있다.\n1개 또는 2개의 피연산항을(operand) 갖는다와 같은 규칙밖에 이어지는 의미가 없고, 연산자 본연의 기능은 제거되니까 말이다.\n(덧셈을 뺄셈으로 쓸 수도 있고, 덧셈을 단지 printf를 호출하는 함수로 만들 수도 있다)\n\n### 추상화(abstraction)\n사물의 본질을 간략히 추려내는것을 말한다.\n프로그래밍 언어에서는 사물의 특징을 포괄할 자료형과 그것을 다루기 위한 적절한 연산을 선택(재사용) 또는 새롭게 정의하는 것을 말한다.\n단어의 선택에서 의미부여가 이루어진다.\n\nex) 내가 만들 슈팅게임의 비행기 댓수를 5로 초기화 하겠다. (int 라는 자료형의 재사용과 의미부여의 예)\nint player_airplane_count = 5;\n\n여기서 남은 비행기 댓수는 chance 의 의미이기도 하다.\nplayer_airplane_count++; 은 게임 속어로 보너스의 예가 되겠다.\n어떤 단어가 개념을 포괄하기에 적절한지 고르는 작업은 혼동을 줄이기 위해, 문제를 정갈히 풀어나가기 위해 정말 중요한 작업이다.\n\n만약 airplane 의 자료형을 PLAYER 객체로 재정의 한다면,\n그에 필요한 연산들도 재정의 할수 있고, 격식을 갖추게 된다.\n``` cpp\nclass PLAYER\n{\nprivate:\nint chance;\npublic:\nPLAYER() { chance = 5; }\nvoid bonus()\n{\nchance++;\n}\nvoid die()\n{\nchance--;\nif (chance < 1)\nmake_event(event_gameover);\n}\n};\n```\n격식을 갖추게 되었다는 말은, 실수할 여지가 줄고 의미가 명확해졌으며, 재사용 가능성이 증가하였음을 의미한다.\n재사용 가능성이 증가되었다는 것은 한 편으로, 수정 필요시 수정할 곳이 한 곳으로 집중되었다는 것을 의미한다.\nchance++; 을 곳곳에 코딩했다면, 수정 필요시 사용된 모든 곳에서 일일이 수정을 해야 하지만,\n(이를테면 10대 이상 증가 못하게 하는 변경점 발생시)\nbonus(); 를 곳곳에 코딩했다면, bonus() 의 정의부분만 수정하면 되는것이지.\n\n### 캡슐화(encapsulation)\n모든 자료는 자료의 존재만으로는 의미가 없다.\n어떤 고고학자(사용자)가 도자기를 발견했다고 가정하자.\n손잡이의 형태를 보고 이것이 어떤 목적을 위한 구조인지 고민할 것이다.\n변수나 자료형만 선언해 놓고 알아서 해~ 하는건 문제 그 자체의 노출이지, 풀이나 해법이 아니다.\n즉, 손잡이의 형태는 필연적으로 쥐는 법과 드는 법, 따르는 법, 걸어서 보관하는 법 등의\n자료형의 구체적인 처리 방법과 뗄래야 뗄 수 없는 것이란거다.\n처리방법이 명세되지 않은 도자기는 그냥 돌덩어리인거지.\n\n하나의 개념적 덩어리 안에서 여러 메서드들이 다루게 될 재료(recipe) 에 대해 공유하는 부분 또한,\n캡슐화가 가지는 팀웍과 우아함이다.\n대중음식점이나, 고급레스토랑의 구조와 처리흐름을(work flow) 생각해보면 어떤 잇점들이 있는지 잘 알 수 있다.\n주문을 받는 웨이터, 웨이트레스들과 요리사는 주문서를 공유하고, 요리의 결과물을 주고 받으며,\n재료의 재고 상태를 공유한다.\n필요시 웨이터들은 재료가 떨어졌음을 (메모리고갈 상태를) 고객에게 디버깅 메시지로 알려주기도 한다.\n\n### 은닉화(hiding)\n흔히 캡슐화와 혼용된다.\n캡슐화의 과정에서, public 으로 공개할지, private 로 숨길지(며느리도 몰라),\nprotected 로 자손들에게만 알려줄지(며느리는 알아)를 서술하게 마련이기 때문이지만,\n분명 개념은 캡슐화와 다르다.\n고객이 식당에 와서 메뉴판을 보며 고르는 행위를 돕기 위해서\n굳이 식당에서 들여오는 계란의 유통구조와 삶는 방법을 메뉴판에 열거할 필요는 없다.\n알아서 나아질 것이 없다면 모르는게 약이다란 뜻이다.\n너무 많은 인터페이스의 노출은 결정적으로 사용자 불편을 초래한다.\n그래서 APPLE 의 미니멀리즘이 성공한거지. (ipod shuffle 같은 mp3 player 등이 좋은 예)\n구글 검색에서 쓸데없는 검색결과들이 당신의 시간을 얼마나 좀먹는가?\n심지어 인터넷에 당신에게 필요한 정보가 있을지라도, 불필요한 정보의 노출에 의해 필요한 내용을 평생 얻지 못할 수도 있다.\n이렇듯 은닉화는 정말 중요한 개념이고, UI 나 인터페이스 설계에서 핵심적인 부분이다.\n\n### 다형성(polymorphism)\n동질이상.\n큰 범주에서 개념이 같지만,\n구체적으로는 다룰 대상, 또는 그 방법에 차이가 있는 방법(연산)을 같은 이름으로 부를 수 있게 하는 것이다.\n\n착각하기 쉬운것은, 프로그래밍 언어에 있어서의 다형성이 일반적인 polymorphism의 개념과 달리,\n비슷한 기능을 하는 서로 다른 함수들을 같은 이름으로 정의하는 것이라는 점. (매개변수의 타잎으로 각각 구분한다)\n즉, 하나의 이름으로 다양한 자료형을 지원하는데 목적이 있다.\n따라서 탬플릿과 목적 및 기능이 유사해 보이지만, 탬플릿은 보다 한정적이고 구체적이다.\n다룰 자료형을 다양화하고 컴파일러로 하여금 실제 사용된 자료형을 다룰 메서드를 자동으로 서술하게 하는게 목적이지\n다루는 방법을 다양화하지는 않기 때문이다.\n\n요약하면, 다형성과 탬플릿은 자료형이나 객체를 다룰 연산자(매서드) 의 이름에 융통성을 주기 위한 것 뿐이다.\n다형성은 같은 이름의 다양한 연산자(매서드)를 서술할 수 있고,\n탬플릿은 같은 이름의 다양한 사용예에 대해 코딩량을 줄여준다.\n\n### 추상화의 결과를 활용하여 구체적인 실례에 적용하는 것이다.\n즉, 추상화를 통해 도출한 일반해로 부터 특수해를 위한 파라메터를 적용하고, 부족한 내용을 추가하는 것이라 볼 수 있다.\n다른 말로, 추상화란것은 철학(프로그래밍은 고유의 notation을 사용하니 언어학 또는 수학)을 하는 것이고,\n상속을 받았다는 것은 응용학문(이를테면 공학) 에 적용하는 것이다.\n추상 객체와 상속을 받은 객체를 사용해 개체(instance)를 생성하고, 정의된 방법들을 이용해\n요구사항을 구현(implement) 하는 것은 생산(production)에 해당하는 것이지.\n\n위에서 예시한 bonus() 함수로의 가공의 예도 클래스 추상화와 상속성으로 확장해 이해할 수 있다.\n즉, 함수오버로딩이란 자식 메서드의 진입시점에서 부모 메서드를 호출해주는 것이다.\n생성자 함수 호출순서 역시 그러하다. 자식 생성자의 실행직전에 부모 생성자들을 재귀적으로 호출해 주는것이지.\n여기서 중요한것은, 우리가 변수와 연산자를 (chance--) 하나의 함수로 싼 것과 마찬가지 잇점들이 객체화로 이어진다는거다.\n이것이 랩핑(wrapping)즉 모듈화, 그리고 encapsulation의 장점이다.\n\n### 클래싱(classing) - 뭐 좋은 한글 없냐?\n목적한 결과물의 형태를 얻어내기 위해,\n우리는 소조를 하든지(붙이기), 조각을 하게 된다. 거푸집이나 틀을 만들고 내용물을 부어넣는 주조(주물) 형태를 취하기도 한다.\n(이를 위해 일시적으로 유동성과 점성을 갖도록 녹이는 작업을 하기도 하지)\n\n원시 자료형(primitives)을 찰흙이나 지점토 처럼 유동성과 점성이 있는 성질로 정의할지,\n대리석처럼 단단한(rigid) 성질로 정의할지,\n일시적으로 점성을 갖거나, 강체(rigid object)끼리 접착할 수 있는(bonding) 형식으로 정의할지는\n언어에서 지원하는 문법과, 개발자의 선택에 달린 문제다.\n즉, 클래싱이란, 위에 언급한 추상객체와 상속객체를 어떤식으로 구성하고 결합할지를 결정하는 것이다.\n\n부모객체 A를 상속받는다는 것은, 객체 A를 멤버로 선언하는 것과 아주 미세한 차이가 있을 뿐이다.\nprotected 접근권한을 허용할지와, override 같은 재정의를 사용할지 말지 정도랄까.\n하지만 그때문에 hard binding 구조가 된다.\n가능하면 상속을 자제하라는 이야기는 light binding을 유지해, 재사용성을 높이라는 이야기다.\n요약하면, 접근권한을 바꿀 여지가 없거나, 가상함수들에 대한 override가 반드시 필요하다면 상속을 받아서 구현하란 이야기다.\n","btime":{"$$date":1478745385722},"mtime":{"$$date":1478745514292},"_id":"eoyjOCMb7Z5SClai"}
{"dirName":"codesafer","subName":"개념글","fileName":"약속한 소스코드","fileData":"\n소스 코드 한장으로 합쳤다.\n``` cpp\n//=============================================================================\n// performance.h --------------------------------------------------------------\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <algorithm>\n\n#define CSTR    // constructor place holder\n#define DSTR    // destructor place holder\n#define _____   // place holder\n\nusing   i8  = char;\nusing   u8  = unsigned char;\nusing   i16 = short;\nusing   u16 = unsigned short;\nusing   i32 = int;\nusing   i64 = long long;\nusing   u32 = unsigned int;\nusing   u64 = unsigned long long;\nusing   f32 = float;\nusing   f64 = double;\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#else\n#include <x86intrin.h>\n#define CHAR_BIT    8\n#endif\n\n#define SYS_BITS    ( sizeof( size_t ) * CHAR_BIT )\n\n//-----------------------------------------------------------------------------\n\nclass                           RUNNER\n{\nprivate:\n    const   char*               function_name;\n    u64                         elapsed;\n\nprotected:\n    bool                        is_success;\n\npublic:\n    CSTR                        RUNNER\n        (\n            const char* function_name,\n            void( *on_pre )( ),\n            void( *on_run )( ),\n            bool( *on_post )( )\n            )\n        : function_name( function_name )\n        , on_pre( on_pre )\n        , on_run( on_run )\n        , on_post( on_post )\n    {\n        init();\n    }\n    DSTR    virtual            ~RUNNER()\n    {};\n\n    virtual void                init()\n    {\n        elapsed = -1;\n        is_success = on_run != NULL;\n    }\n\n    void( *on_pre )( );\n    void( *on_run )( );\n    bool( *on_post )( );\n\n    void                        check()\n    {\n        if( !on_run )\n            return;\n        if( on_pre )\n            on_pre();\n\n        u64     begin = __rdtsc();\n        on_run();\n        u64     duration = __rdtsc() - begin;\n        elapsed = std::min( elapsed, duration );\n\n        if( on_post )\n            is_success &= on_post();\n    }\n    const   auto                set_length( const char* str, const size_t size )\n    {\n        static  char    temp[ 80 ];\n        size_t          index;\n        for( index = 0; str[ index ]; ++index ) temp[ index ] = str[ index ];\n        for( ; index < size; ++index ) temp[ index ] = ' ';\n        temp[ index ] = 0;\n        return  temp;\n    }\n    const   auto                report()\n    {\n        const   char* judge_strings[] = { \" FAILED        \", \"        PASSED \" };\n        static  char temp[ 80 ];\n        sprintf( temp, \"[%s] %s llu clocks\", judge_strings[ is_success ],\n                 set_length( function_name, 20 ), elapsed );\n        return  temp;\n    }\n    const   auto                elapsed_clocks()\n    {\n        return  elapsed;\n    }\n    const   auto                name()\n    {\n        return  function_name;\n    }\n\n};\n//-----------------------------------------------------------------------------\n\n#include <vector>\ntemplate < size_t REPEAT_COUNT = 1 >\nclass                           BENCH\n{\nprivate:\n    std::vector< RUNNER* >      runner_list;\n\npublic:\n    CSTR                        BENCH()\n    {};\n    DSTR                       ~BENCH()\n    {};\n\n    void                        add( RUNNER* runner )\n    {\n        runner_list.push_back( runner );\n    }\n\n    void                        run()\n    {\n        if( runner_list.size() == 0 ) return;\n        printf( \"< %d bits > %d trials\", (int)SYS_BITS, (int)REPEAT_COUNT );\n        puts( \"\" );\n        puts( \"-------------------------------------------------------------\" );\n        puts( \"|  CHECKER      | Function  name      |   minimum  clocks   |\" );\n        puts( \"-------------------------------------------------------------\" );\n        u64 min_value = -1;\n        u64 max_value = 0;\n        u32 min_index = 0;\n        u32 max_index = 0;\n        for( u32 test_case = 0; test_case < runner_list.size(); ++test_case )\n        {\n            runner_list[ test_case ]->init();\n            for( u32 test_count = 0; test_count < REPEAT_COUNT; ++test_count )\n                runner_list[ test_case ]->check();\n            puts( runner_list[ test_case ]->report() );\n            if( min_value > runner_list[ test_case ]->elapsed_clocks() )\n            {\n                min_index = test_case;\n                min_value = runner_list[ test_case ]->elapsed_clocks();\n            }\n            if( max_value < runner_list[ test_case ]->elapsed_clocks() )\n            {\n                max_index = test_case;\n                max_value = runner_list[ test_case ]->elapsed_clocks();\n            }\n        }\n        puts( \"-------------------------------------------------------------\" );\n        printf( \"Winner is %s  ( %.2f times faster than loooser )\",\n                runner_list[ min_index ]->name(),\n                float( runner_list[ max_index ]->elapsed_clocks() ) /\n                runner_list[ min_index ]->elapsed_clocks() );\n        puts( \"\" );\n    }\n};\n//-----------------------------------------------------------------------------\n\n#define COOL_FUN( function_name, ... )\n    new RUNNER( #function_name, nil, []{ function_name(__VA_ARGS__); }, nil )\n\n#define SO_FUN( pre, function_name, ... )\n    new RUNNER( #function_name, pre, []{ function_name(__VA_ARGS__); }, nil )\n\n#define FUN( pre, run, post, function_name )\n    new RUNNER( #function_name, pre, run, post )\n\n//=============================================================================\n// kukyakya\n\n#include <memory>\n#include <cassert>\n\nusing byte = char;\nusing word = std::size_t;\n\nword merge_word( const word& w1, const word& w2, std::size_t byte_offset )\n{\n    assert( byte_offset && ( byte_offset < sizeof( word ) ) );\n\n    const std::size_t shift_1 = CHAR_BIT * byte_offset;\n    const std::size_t shift_2 = CHAR_BIT * sizeof( word ) - shift_1;\n\n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n    return ( w1 >> shift_1 ) | ( w2 << shift_2 );\n#else\n    return ( w1 << shift_1 ) | ( w2 >> shift_2 );\n#endif // __BYTE_ORDER\n}\n\nstd::size_t get_byte_offset( const word* ptr )\n{\n    void *p = (void*)ptr;\n    std::size_t sz = -1;\n\n    std::align( alignof( word ), 0, p, sz );\n\n    const auto diff = (char*)p - (char*)ptr;\n\n    return ( diff == 0 ) ? 0 : ( sizeof( word ) - diff );\n}\n\nbyte* copy_byte( byte* dest, const byte* src, std::size_t n_byte )\n{\n    // Don't fuck with loop-unrolling, just trust your compiler\n    while( n_byte-- )\n        *dest++ = *src++;\n\n    return dest;\n}\n\nword* copy_word_both_aligned( word* dest, const word* src, std::size_t n_word )\n{\n    /* */ word* d = (word*)dest;\n    const word* s = (const word*)src;\n    while( n_word-- )\n        *d++ = *s++;\n\n    return dest;\n}\n\n// src is not aligned\nword* copy_word_dest_aligned( word* dest, const word* src, std::size_t n_word )\n{\n    word *d = dest;\n    const word *s = src;\n\n    // get byte-offset of src\n    std::size_t src_offset = get_byte_offset( s );\n\n    // if src is aligned, call copy_word_both_aligned\n    if( src_offset == 0 )\n    {\n        return copy_word_both_aligned( d, s, n_word );\n    }\n\n    const word* aligned_src = (const word*)( (char*)s - src_offset );\n    assert( get_byte_offset( aligned_src ) == 0 );\n\n    word buf = *aligned_src++;\n    while( n_word-- )\n    {\n        word buf2 = *aligned_src++;\n        *d++ = merge_word( buf, buf2, src_offset );\n        buf = buf2;\n    }\n\n    return dest;\n}\n\nvoid *kukyakya_memcpy( void* dest, const void* src, std::size_t n )\n{\n    /* */ void* d = dest;\n    const void* s = src;\n    std::size_t sz = n;\n\n    if( !std::align( alignof( word ), 0, d, sz ) )\n    {\n        return copy_byte( (byte*)dest, (const byte*)src, n );\n    }\n    s = (const byte*)s + ( n - sz );\n\n    // byte copy until dest is aligned\n    copy_byte( (byte*)dest, (const byte*)src, n - sz );\n\n    // copy words\n    const std::size_t n_word = sz / sizeof( word );\n    copy_word_dest_aligned( (word*)d, (const word*)s, n_word );\n    d = /* */ (word*)d + n_word;\n    s = (const word*)s + n_word;\n    sz -= sizeof( word )   * n_word;\n\n    // copy remaining bytes\n    copy_byte( (byte*)d, (const byte*)s, sz );\n\n    return dest;\n}\n\nvoid *kukyakya_memcpy_unaligned( void* dest, const void* src, std::size_t n_byte )\n{\n    /* */ word *d = (/* */ word*)dest;\n    const word* s = (const word*)src;\n\n    // copy word\n    const std::size_t n_word = n_byte / sizeof( word );\n    copy_word_both_aligned( d, s, n_word );\n\n    d += n_word;\n    s += n_word;\n    n_byte -= n_word * sizeof( word );\n\n    // copy remaining bytes\n    copy_byte( (byte*)d, (const byte*)s, n_byte );\n\n    return dest;\n}\n\nvoid *my_memcpy_byte_only( void* dest, const void* src, std::size_t n )\n{\n    return copy_byte( (byte*)dest, (const byte*)src, n );\n}\n//=============================================================================\n\nvoid* codesafer_memcpy_unaligned1( void* dst, const void* src, std::size_t size )\n{\n    using   step_t    = u32;\n\n    _____   step_t* d = (step_t*)dst;\n    const   step_t* s = (step_t*)src;\n    const   std::size_t step_count  = size / sizeof(step_t);\n    const   u32         off_road    = size % sizeof(step_t);\n\n    for( std::size_t i = 0; i < step_count; ++i )\n        d[i] = s[i];\n\n    u8* db = (u8*)( d + step_count );\n    u8* sb = (u8*)( s + step_count );\n\n    for( u32 i = 0; i < off_road; ++i )\n        db[i] = sb[i];\n\n    return  dst;\n}\n//=============================================================================\n// test case\n\nconst int   test_count = 100;\nconst int   test_size  = 1000000;\n\n#ifdef _MSC_VER\n__declspec( align( 4 ) )   char src[ test_size + 4 ];\n__declspec( align( 4 ) )   char dst[ test_size + 4 ];\n#else\nchar src[ test_size + 4 ] __attribute__((aligned(4)));\nchar dst[ test_size + 4 ] __attribute__((aligned(4)));\n#endif\n\nint         result1, result2, result3, result4;\n\nvoid init()\n{\n}\n\nvoid pre()\n{\n}\n\nvoid test1()\n{\n    result1 += (int)kukyakya_memcpy( dst + 1, src + 3, test_size );\n}\n\nvoid test2()\n{\n    result2 += (int)kukyakya_memcpy_unaligned( dst + 1, src + 3, test_size );\n}\n\nvoid test3()\n{\n    result3 += (int)memcpy( dst + 1, src + 3, test_size );\n}\n\nvoid test4()\n{\n    result4 += (int)codesafer_memcpy_unaligned1( dst + 1, src + 3, test_size );\n}\n\nbool post()\n{\n    return  true;\n}\n//-----------------------------------------------------------------------------\n\n#include <iostream>\n\nusing   namespace   std;\n\nint main()\n{\n    init();\n    BENCH< test_count > bench;\n    bench.add( FUN( pre, test1, post, kukyakya_aligned ) );\n    bench.add( FUN( pre, test2, post, kukyakya_unaligned ) );\n    bench.add( FUN( pre, test3, post, std_memcpy ) );\n    bench.add( FUN( pre, test4, post, codesafer_unaligned1 ) );\n    bench.run();\n\n    return  0;\n}\n```\n","btime":{"$$date":1478745312564},"mtime":{"$$date":1478745312564},"_id":"gntFqmUk5XqFENU1"}
{"dirName":"codesafer","subName":"C++ 초보를 위한 강좌","fileName":"02. 하지만 API 는 지저분하다.","fileData":"## 하지만 API는 지저분 하다?\n\n우리네 틀딱 선배님들이 젊은 시절에 열심히 만들어둔 운영체제의 틀은\n수많은 수정요구에 의해서 타협하고 수정되고 버려지고 대체되면서 시궁창이 되어버렸다.\n\n물론 정리가 잘 된 운영체제의 개발환경도 있고,\nUnix 를 바탕으로 만들어진 ( 사실상 운영체제의 표준격인 ),\nPOSIX 정의를 잘 따르는 인터페이스들도 있다.\n\n하지만 우리가 주로 사용하는 Windows 의 API 란건 쓰레기도 이런 쓰레기가 없을 정도다.\n그걸 조금 편해 보겠다고 객체같지도 않은 MFC 로 싸버렸으나 노답인건 매한가지,\n상대적으로 진보적인 프레임웍이었던 VCL 의 개발 책임자를 사 와서 .Net 을 만들었으나\n.Net 환경 프로그래밍 또한 그렇게 매력적이진 않다. ( 물론 MFC 보다 나은건 인정 )\n\n우리가 가장 큰 데스크탑 시장의 개발환경을 과감히 포기할 용기가 없다면,\n이 그지 발싸개 같은 운영체제를 우리는 써야 하고 배워야한다.\n아~~주 잘못 만들어져 있다는걸 깨닫는데 오랜시간이 걸리지 않겠지만 말이다.\n다행스럽게도 당신이 좋은 프레임웍을 선택한다면,\n그지 발싸개랑 대화하기 위해 그지 발싸개를 이해하는데 필요한 시간을 줄일 수 있다.\n\n여기서 여러분은 선택해야 한다.\n\n1. 여러 운영체제용으로 포팅이된 프레임웍을 이용해 조금 더 상위 레벨에서 프로그래밍 할 것인가?\n   그를 통해 여러분은 다른 운영체제에서도 쉽게 돌아갈 수 있는 프로그램을 만들 수 있다.\n\n2. 그지 발싸개 ( Windows API )를 공부해서 \"난 빌게이츠를 사랑해요\"를 외칠 것인가?\n   미안하지만 이 공부는 최소화 하는게 낫다.\n   윈도우 디바이스 드라이버나 자유자재로 만들면서 먹고 살 틈새를 기대하는게 아니라면.\n   ( 그나마도 꽤 비싼 드라이버 인증 비용을 물어야 최신 Windows 운영체제에서 실행해 줄 것이다 )\n\n3. .Net 기반환경에서 개발할 것인가?\n   CLI 라는 인터페이스가 있으나 이건 C++ 이 아니라고 보는게 맞다.\n   그럴거면 차라리 C# 을 써라. MS 도 Windows 전용을 포기한것 같던데.\n\n4. 윈도우즈 버려!\n   축하한다. 너 금수저.\n\n다시한번 말하지만 Windows 는 쓰레기다.\n하지만 제법 두꺼운 콘크리트 기반을 깔고 산다면 지하가 쓰레기 매립지인줄 모르고 살 수 있다.\n가끔 우물 파는 사람들은 경악하겠지만.\n\n그러니 정신건강을 생각한다면, Windows API 를 대체할 무언가를 선택하는게 좋다.\n컴파일 시간을 부스팅 시켜주는 boost 도 좋은 예이고,\npoco 같은 프레임웍을 쓸 수도 있다.\n\nGUI 가 필요하다면 OpenGL 기반의 여러 프레임웍들이 준비되어 있다.\n크로노스 그룹에서 지원하는 OpenXXX 프로젝트들은\n여러분이 그 기반위에서 작성한 프로그램들이 여러 운영체제에서 돌아갈것을 약속해준다.\n\n조금은 더 편하고 조금 더 진보적인 프레임웍을 선택하라는 이야기다.\nMS 너무 까서 MS 빠들에게 미안하다만,\n까일만 하다.\n\n앞으로 이 강좌 씨리즈가 어떻게 흘러갈지 나도 모르지만,\n일단은 OOP 와 TMP 위주로 진행할 것 같다.\n그게 좀 더 범용성을 띤다고 생각되어서 말이다.\n\n초보자들이 사용하기에 편리한 프레임웍들이 있다면 여러 사람들이 추천해줬으면 한다.\n","btime":{"$$date":1478742085353},"mtime":{"$$date":1478744515450},"_id":"hJ6XafsyeSdBjiBr"}
{"dirName":"codesafer","subName":"개소리","fileName":"직급에 따른 적절한 태도","fileData":"## 직급에 따른 적절한 태도\n\n1. 신입\n회의때 절대 졸지마라.\n다른 사람의 발언시간에 자기랑 관련없다라거나 할 일없다고 생각하면 졸립지.\n못알아듣는 단어들이 나오면 자신과의 연관성을 따져서, 높으면 기억해뒀다가 찾아볼 것.\n자신과 연관되지 않은 이슈들이 거론될 때는 그 문제가 왜 거론되었는지 생각해보거나,\n자신이 해야할 다른일들에 대해 생각해라.\n능동성이 가장 중요한 부분.\n그러면 회의에 졸지 않을 수 있다.\n하다못해 어떤식으로 발표하는게 듣기 좋고 전문성있게 들리는지라도 관찰해라.\n노래도 발표도, 내용만큼이나 호흡이 중요하다.\n스스로 주어진 문제를 명확히 정리해보고,\n모호하다 생각되는 부분을 분명히 표시해서 바로 위 고참에게 물어라.\n그 고참을 뛰어넘어 더 윗사람에게 묻는건 하극상일 수 있으니 조심.\n만약 윗사람이 노답이더라도 아직은 티낼 수 있는 처지가 아님.\n짤리기 싫으면 진지해라. 약간의 미소 정도는 좋다. 유머가 너무 길거나 계속 실실 쪼개면 병신같음.\n\n2. 연구원\n닥치는대로 공부.\n자발적 야근 추천. (집에 가봐야 할 일도 없는거... 어차피 니들 주제에 여친도 없는거... 공조비랑 야식비나 축내는거다)\n일단 너 혼자 마무리 지을 수 있는 규모 있는 프로젝트는 거의 없다고 보면 된다.\n규모있는 프로젝트에 너한테 일 나눠주는것도 고참들한텐 피곤함이다.\n허드렛일이 니 공부보다 우선이다. 컨텍스트 스위칭이 잦아진다는걸 의미한다.\n하지만 공부하지 않으면 결코 너에게 미래란 없다.\n발표를 똑똑히 하고, 생각을 조리있고 짧게 전달해라.\n너의 상관들은 해당분야의 전문용어 몇 단어로 설명될 문제를 장황하게 늘어놓는 너로 인한 시간낭비를 아까워한다.\n딴생각 하지마라. 사소한 일도 약속도 꼭 지켜라.\n윗사람을 존경해라.\n윗사람 마음을 열지 못하면 얻을것도 없다.\n연애는 포기해라.\n\n3. 주임 연구원\n이쯤되면 진행중인 프로젝트들의 상황을 정확히 보고할 수 있는 수준이어야 한다.\n능력 여하에 따라 진행과정의 문제점을 파악, 대안을 제시할수도 있다.\n대안 제시가 적절할 수록 진급가능성이 높아진다고 보면 된다.\n일단은 작은 일들을 처리할 수 있는 단계.\n아직까지는 커뮤니케이션 비용이 비싸다.\n즉 대화를 많이 해야하고, 필요하면 관련 업체에 전화질을 열심히 해야한단 소리다.\n고참의 시간을 뺏는건 회사(연구소)의 생산력감소와 경비지출을 의미한다.\n공짜 아웃소싱을 할수 있는 리소스들을 확보해라.\n슬슬 정치맛을 보게 되는 시기.\n하지만, 타인을 까는 자리에 동참하진 마라. 아직은 많이 이르다.\n연애는 자중해라.\n\n4. 선임 연구원\n이제 적어도 니가 관리해야 하는 사람이 생겼겠지.\n네게 맡겨진 일들에 조직이 신뢰를 보이기 시작한다.\n전술적인 부분에 최적화를 경험해야할 시기.\n경우에 따라 프로젝트 하나가 통째로 주어지기도 한다.\n부분적인 최적해에 관련해 논문들을 준비해라.\n다른 부서의 일을 뺏아와라.\n대신 니네팀 후임들은 조져서라도 일을 하게 만들어라.\n니 위 책임급의 보좌관으로서 진행중인 내용들을 누구보다도 정확히 알고 있어야 한다.\n일에 있어선 똑 부러지고, 대인관계에선 스마일 하는게 좋다.\n무능한 적을 단 한 사람으로 한정할수록 효과적으로 디스할 수 있다.\n연애를 해도 뭐랄 사람은 없을거야.\n\n5. 책임 연구원\n하나 이상의 프로젝트를 총괄하게 된다.\n관리해야하는 인원이 많으니, 대화비용도 늘고, 따라서 효율적인 대화의 방법에 대해 고민해 보아야 한다.\n팀내 불협화음의 요인에 대해 고민해야 한다.\n대개 법인카드로 긁겠지만, 사적인 회식비 지출도 늘게 된다.\n이제 슬슬 장가갈 고민을 해보는것도 나쁘지 않다.\n야근을 줄이고 자기계발에 힘써라.\n대신 출근전 샤워하면서, 잠자리에 들어 잠들기까지, 오늘 해야 할 일과 오늘까지 했던 일의 내용을 머릿속으로 정리해라.\n특수한 경우의 최적해 보단 일반적인 경우들에 통용될 수 있는 파라다임을 고민해야 할 때다.\n협조를 원할히 할 수 있도록 다른 프로젝트에 할당된 책임들과의 교류에 힘써라.\n가능하면 바로 아래 직급들과 충분히 대화를 해서, 그보다 더 아래 직급들까지 시시콜콜히 간섭하지는 않도록 해라.\n책임급 회의에 참석하게 될텐데, 아랫사람들을 잘 보호하고,\n그들의 성과들을 솔직 + 멋진 연출을 조금 섞어서 다른 부서와 상급자들에게 알려라.\n후임들의 성과를 칭찬하는데 인색한 사람이라면, 그들은 널 상급자로 두지 않을거야.\n후임 연구원들의 문제를 커버해 줄때도 두 번을 넘지 않도록 하고, 답이 없을 것 같을땐 결단을 내려라.\n새로 사람을 들이는건 교육과 대화의 비용이 늘지만, 안되는건 안된다고 책임의 범위를 한정짓는게 좋다.\n\n6. 수석 연구원\n이젠 본격적으로 정치판이다.\n필요하면 이혼할 고민을 해보는것도 나쁘지 않다.\n슬슬 창업 아이템을 고민해봐야 할 시기다.\n인적네트워크 관리를 잘 해라.\n빈손으로 나와 창업하겠다는 생각을 버리고, 회사의 자원과 지원을 적당히 잘 활용해서 준비해라.\n이전까지는 일을 뺏아오고 능력을 키우는데 주력했다면, 이젠 일을 슬슬 풀어줘야 된다.\n너보다 부족해 보이는 책임, 선임급들의 업무진행에 신뢰를 나눠줘라.\n대신 과정과 결과에서 어떤 부분이 미흡한지 충분히 알려줘라.\n슬슬 체력적 한계도 경험하게 될테고, 니가 지쳐 있을때나 다른 일로 바쁠때도 업무가 돌아가게끔\n니 아랫사람들을 한단계 높은 레벨의 완성도로 도전하게 만드는게 중요한 이슈다.\n이걸 못하면 걍 평생 연구원으로 남아야된다. 창업해봐야 별 수 없을게야. 일을 혼자 싸짊어지고 늙어갈테니.\n가르치고, 네 사람으로 만들어라.\n넌 더 큰 그림을 그리는데 적합하게 바뀌어야하고, 구체적인 그림은 바로 아랫사람들이 그리게 해라.\n젊은 사람들의 생각을 이해하고, 젊은 사고를 유지하도록 애써라.\n매너리즘에 빠져 모두 내려놓다간 훅간다. 노화의 속도를 늦춰라.\n\n7. 연구위원\n전략적인 이슈에 바쁘게 뛰어다녀야 한다.\n사업화의 최소비용과 최대성과에 대해 고민할 시기.\n어차피 지금부터는 계약직이니 퇴직금 노릴것도 아니고,\n데리고 나갈 수 있는 사람과 심어놓을 사람을 나눠 잘 관리해야 한다.\n심어놓을 사람들은 니가 나가서 창업했을때 아웃소싱을 도와줄테고,\n데리고 나갈 사람들은 니가 앞으로 먹여살려야 할 사람들이다.\n반대로 그들이 너를 먹여살려주기도 하고 말야.\n창의력이 없으면 니 미래는 암담하다.\n똑똑한 친구들의 이야기를 귀담아 들어라.\n상냥한 인사와 과하지 않은 개인적인 회식을 통해 적은 비용으로 너의 호감도를 관리할 수 있다.\n창업을 위해서는 기술멤버만 필요한게 아니다.\n회계, 사업지원, 생산, 여러 분야의 지인들을 만들고, 적당히 피로도가 쌓이지 않게 유지해라.\n사적인 취미모임(등산, 골프)을 통해 여러분야의 전문가들을 사겨라.\n이젠 노트의 필요성이 극대화되는 시기다. 생각의 조각들이 사라지지 않도록 잘 정리해 봐라.\nmp3 녹음기를 쓰든 뭘 하든.\n경험이 부족하다면 재혼을 고민하겠지만,\n바보가 아닌이상 연애나하는게 현명하다는걸 깨닫게 되었겠지.\n","btime":{"$$date":1478745690869},"mtime":{"$$date":1478745690869},"_id":"hUXk1Y8rrfC1ie2l"}
{"dirName":"codesafer","subName":"뻘소리","fileName":"엘리트그룹과 열등그룹","fileData":"## 엘리트 그룹과 열등 그룹\n\n어릴때 어머니가 친구는 가려서 사겨라 하실때,\n응? 넌 친구 쟨 친구 아니야. 를 어케 해. 친구면 친구지.\n라고 말했는데,\n\n은근 성장하면서 친구를 가려서 사겼던 것 같다.\n그래서, 내가 아끼는 사람들은 같이 성장할수 있도록 서로 북돋웠던 것 같다.\n\n살면서 여러 그룹에 속해봤다.\n\n엘리트그룹은\n진지한 엘리트 그룹과, 재능이 넘쳐 게으른 엘리트 그룹으로 나뉜다.\n둘의 공통점은, 긍정적일때 무척이나 집중한다는 것이다.\n그 집중도와 지속시간의 차이가 있는 정도.\n\n그런데 엘리트그룹이 가지는 가장 큰 문제는,\n자신의 체면, 오만방자를 떠느라 허비하는 시간이 세금이란 거다.\n그리고, 잘 정제된 규칙과 금언속에는\n특수화되고 다변화한 실세계와 동떨어진 이질성을 갖고 있다.\n\n열등그룹에 들어가보면,\n이 그룹이 가지는 문제는 두 가지다.\n1. 프라이드가 없음\n2. 집중하지 않음\n위의 엘리트 그룹이 가지는 장점과 당연히 반대다.\n사실 같은 경계 위치를 갖는다는건 그 위치가 + 냐 - 냐 와 상관없이 본질적 동치인 관계로\n엘리트그룹의 문제는 열등그룹의 장점이 되고, 열등그룹의 단점은 엘리트그룹의 장점이 되는 것.\n오히려 열등그룹에 가까운게 세상의 본질이다. 곧 시장 그 자체이기도 하다.\n\n두 그룹에 속해 보면서 깨달은건,\n\n삼인행이면 필유아사 란 말의 되새김이다.\n늘 배우고 스스로를 다듬을 것들이 어느그룹에나 있는 것이다.\n고인 물은 썩는다.\n\n엘리트그룹을 통해 모범과 이상세계의 어리석음을 배우고,\n열등그룹을 통해 현실적 문제와 필요를 배운다.\n\n그래서 잡스가 stay hungry 를 외쳤던것.\n그 말은 둘 다에 속하란 뜻이겠지?\n동시에 어느쪽에도 머물지 마란 뜻이고.\n\n물은 포도주가 될 수 있지만,\n다시 물이 될 수 없는 포도주는 갈 곳이 없다","btime":{"$$date":1478746088829},"mtime":{"$$date":1478746088829},"_id":"iu2L5ovuP4fuqN6K"}
{"dirName":"codesafer","subName":"개념글","fileName":"멀티쓰레딩, 멀티테스킹, 멀티프로세싱, 멀티프로그래밍, 멀티코어란","fileData":"## 멀티쓰레딩, 멀티테스킹, 멀티프로세싱, 멀티프로그래밍, 멀티코어란?\n\n0. 모든 처리(process)는 통신, 즉 장치(device, equipment), 작은 단위의 장치들로 큰 단위의 장치를 이루는(unit) 블럭들 간의\ncommunication 의 과정이다.\n\n1. 멀티프로세서와 멀티코어, 그리고 채널, 또한 DMA, 그리고 co-processor\n\n흔히 아는 사실이지만, 이건 관습적인 이슈다.\n아주 오랜 옛날 코세가 담배 배우기 전, 혹은 태어나기 전,\n\nCPU(Central Processing Unit : 중앙 처리 장치)는 계산하기도 바빴기 때문에(너무 느려 느려~),\n입력과 출력을 담당하는 별도의 프로세서가 필요했다.\n그걸 Channel 이라고 불렀다. 요즘은 그 관습이 이어져 DMA(Direct Memory Access) Channel 이란 표현을 쓴다.\nCPU 에게 부담을 주지 않고 주변장치가 메모리에 직접 접근(Access : Read & Write)하는 방식을 이야기 하는 것이지.\n\n초기에는 하나의 반도체 chip 을 하나의 패키지에 담고 Processor 라고 불렀고,\n하나의 메인보드 위에 여러개의 패키지를 장착할 수 있게 하는것을 Multi Processor 라고 불렀다.\n\n그러다, 집적도가 높아지면서 하나의 패키지에 여러 chip 을 담기 시작했고, 그걸 Multi core 라고 부르게 되었는데,\n지금은 그 경계가 모호하지. 하이퍼 쓰레딩에서 논리 코어로 나눠버리기도 하고 말야.\n\n또한 이미 출시된 프로세서의 부족한 연산능력을 보완하기 위해 보조 프로세서가 등장하게 되었다. (흔히 알고 있는 80x87 시리즈)\n주로 부동소수점 연산을 보조하게 되었는데, 486 부터는 FPU(부동소수점 연산 장치)가 chip 에 통짜로 구워지게 되었고,\nco-processor 라는 개념이 사라지기 시작했지. 지금은 DSP 같은 것들이 병렬 파이프라인과 SIMD,\n더 큰 단위의 수학적 계산 명령어들을 담고 있다.\n\n\n2. Interrupt, IRQ, PIC\n\nCPU 와 주변장치들이 독립적으로 구동되면서 주변장치에 일일이 프로세서를 할당해 통신하는 비용을 줄이기 위해,\nPIC 라는 구조를 채용하게 되었다. Programmable Interrupt Controller 라는 거지.\n여러 사건들을 인터럽트로 가공해 제어하는데, 프로그램으로 제어할 수 있게 만들겠다는거여.\n어찌되었건 PIC 의 실체는 전통적으로 메인보드에 달려 있는 칩셋 하나다. (8259A 칩)\n\n물론 예외적으로 NMI 가 있다. (Non-maskable Interrupt)\n난 NMI를 알기 전에 PC의 IRQ 목록을 보면서 0번은 타이머구나 1번은 키보드구나... 이런식으로 이해했기 때문에\n(책을 보고 공부한게 아니라 말이지)\n아하~ 가장 중요한건 시간/시각 이다. 라고 생각했었음. (물론 클럭 동기화가 필요한 칩셋의 구조상 틀린 말은 아닌데)\n나중에 컴공에서 수업을 들으며 NMI 즉, 인터럽트 서비스 루틴을 가로챌수 없는 인터럽트가 전원 관련 이슈라는걸 배우게 되었지.\n이제 전원떨어진다~ 같은건 건들지 말란 소리임. 워낙 크리티컬 해서 UPS(무정전 전원 장치) 같은 고비용의 장치가 있던 시절이니까 말야.\n(UPS - battery - built-in 인 노트북 짱짱맨~)\n그래서 Unix 계열 운영체제는 실행중인 시스템의 보호를 위한 여러가지 정책을 갖고 있다.\n배터리 로우나 전원 떨어짐 같은(캐패시터로 버티는 잠시간의 시간동안) 이벤트에 하드디스크에 백업할지 버릴지 그런 것들 말야.\n어쨌든, PIC 는 인터럽트 마다 우선순위를 두어(IRQ) 요청을 처리하게 된다.\n\n\n3. Multi tasking\n\n정보통신공학개론 같은걸 들어보면, 분할 다중화 방식에 대해서 이야기 한다. (Division Multiple Access)\n즉, 하나의 매체, 통로(bus)를 이용해 여러가지 처리를 하는 방식을 논하는 것으로,\nFDMA (Frequency ~ : 주파수 분할 다중화 방식), TDMA (Time ~ : 시분할), CDMA (Code ~ : 코드분할) 을 이야기 하지.\nFDMA는 주파수로 구분된 AM/FM 라디오를 생각하면 편할테고,\nTDMA 는 주로 유선 전화교환망,\nCDMA 는 무선 전화기를 떠올리면 됨.\n\nCPU에선 무선따위가 없으니 다중화를 위해 TDMA 를 구현하게 된거고,\ntime slot 을 잘게 쪼개 여러가지 일을 동시에 수행하게 한거다.\n과거 8비트 APPLE 시절에 믿을 수 없는 4중 화음! 이라고 광고한 소프트웨어는\nTDMA 를 통해 FDMA 를 에뮬레이션 한거라 볼 수 있지.\n오늘날의 마이크와 스피커도 마찬가지 구조고 말이야. -> 신호처리에서 nyquist frequency 로 이어지는 이야기다.\n\n고전적으로는 인터럽트가 발생하면 처리하던 절차적인 작업을 잠시 중단하고, 다른 작업을 하고 오는 수준으로\n빠르게 스위칭 하는걸 multi tasking 이라고 하지만 말야.\n(그래서 Instruction Fetch Cycle 을 개념적으로 나눌 때 Interrupt 처리를 넣기도 하고 안넣기도 하지)\n\n\n4. Multi processing\n\n어느덧 운영체제에서 multi tasking 을 지원하고, 하드웨어에서도 지원하게 된다.\n자꾸 동시성에 대한 요구들이 나오니까 말야.\n하드웨어에서 CPU를 여러개 장착하는건 굳이 구구절절 설명할 여지가 없겠다.\n심지어 하나의 장비에 여러 메인보드, 여러 운영체제를 박는 경우도 있긴 해. ETS 같은 장비들이지.\n\n여기서 동시성을 주의깊게 생각해 볼 필요가 있겠다.\n\n두 친구가 취직을 위해 서울에 상경했다고 생각해 보자.\n야 너 값싼 방 좀 알아봐. 나도 좀 알아 볼 께.\n이런 경우는 한 가지 일을 나눠서 하는 경우지.\n이때 주의할 점이 뭐겠냐?\n둘 다 같은 방을 알아보고 있으면 낭비란거지. -> 그래서 보통 같은 일을 할땐 구역을 나눈다. ->\n니가 신설동을 뒤져 내가 제기동을 뒤질게 이런식.\n\n또한, 식당의 예를 생각해 볼 수 있겠지.\n마스터 쉐프가 다른 동료들에게 재료를 다듬어 데쳐올 것을 요구한다 치자.\n각자 일을 하다가. 재료는 준비되었나? 물어보겠지.\n그리곤 task 가 합쳐지는거다. 이때는 직렬화 혹은 동기화가 필요하다고 하는거지.\n\n아예, 둘이 상관없는 일을 하는 경우도 생각해 볼 수 있겠지.\n이런 경우는 극히 드물지만, 동기화가 필요없어 안전한 경우기도 하다.\n누군가는 데이타를 만들어서 메모리에 적고, 누군가는 화면에 뿌리기만 하는 경우가 되겠다.\n대개의 GUI는 Multi threading 을 지원하지 않는다. VCL 이든 C# 이든 Java 환경이든\n동기화 문제 때문에 thread unsafe 하다고 말하는경우지.\n하지만 그리는걸 한 놈만 관장하고, 읽기 전용으로 데이타에 접근할 때,\n이런 비구속적 동기화, 어떻게 보면 비동기적 동시화 구조가 가능하다는 거지.\n\n\n5. Muti-programming\n\n흔히 듣도 보도 못했을? 단어가 등장한다.\n이름만 거창하지 이건 뭐 별거 없어. channel 의 계보를 잇는거고,\n위에서 말한 마지막 구조 즉 별도의 동기화가 필요치 않은 동시 처리를 이야기 하는거다.\n입출력을 기다리지 않고 주된 처리를 돌리겠다. 즉, 주된 처리 혹은 입출력을 백그라운드로 돌리겠다는 의미를 말한다.\nUnix console 명령어 & 가 fork 명령을 겸하는 것 같은거쥐.\n\n\n6. Muti-thread & Multi-process\n\n자꾸 하고싶은 이야기가 튀어다녀서 좆같다. 시발. ENTP 하여튼 셀프 자살 추천. ㅠㅠ\n초기 Unix 시스템들은 thread 개념이 없었다.\nPOSIX 에서 운영체제 표준을 이야기 하지만, Digital Unix 들은 영영 thread 따윈 없었다.\n즉 독립된 메모리 공간(Protection mode)을 사용하는 Process 를 여러개 생성(folk)시켜 동시에(시간을 잘게 나눠) 처리되도록\n지원했다는거지. 당연히 독립된 메모리 공간끼리 서로 동기화(synchronize)가 필요한 경우, 서로 통신 할 방법이 필요하다.\n\n그래서 IPC 가 나오게 되었지. (Inter-process-communication)\nmessage queue 니, message 니(이건 좆같은 windows), signal 이니(요건 좀 원초적이군),\nmemory mapped file 이니, shared memory 니, pipe 니, named pipe 니 하는 것들 말야.\n덧붙여. 내 외부, 장치간 통신도 가능하게 하는 socket 멋지쥐. (socket 이거 짱먹음)\n여기서 말하고픈건 모든건 필요에 의해서 나왔다 이거야.\n\nIPC 가 무겁지. Process 도 무겁지. 뭐가 무겁냐고? 구현하기 귀찮고 동기화 하기 귀찮고, 시발 다 귀찮다는거여.\n그래서 Thread 가 나왔다. (이거 짱먹음)\n\n하나의 프로세스 안에서 같은 메모리 공간을 공유하면\n구차하게 파이프 뚫고 개지랄 떨지 않아도 동기화된 동시성을 만족시킬 수 있잖아?\n라는 아이디어지.\n\n모든 프로그램은 엔트리 포인트를 가진다. DLL 조차도 Load, Unload 를 위한 Entry point 를 가진다.\nEnter 라는게 어떤 의민지는 알쥐? Entry point 라는 것도 같은 맥락에서 해석해라. 진.입.점.\n운영체제의 shell 밖에서 응용프로그램이나 사용자, 혹은 운영체제가 어떤 프로그램을 실행한다는건,\n실행파일의 포맷을 해석해서(PE든 ELF든 뭐든) 메모리 공간을 확보, 그 위에 풀어놓고,\nPC (Program counter 혹은 Instruction Pointer)가 엔트리 포인트로 뛰어간다는걸 의미한다.\n즉 C 언어에선 main 함수가 되는거고,\n엔트리 포인트의 함수를 실행하는게 프로세스가 생성된다는걸 의미한다는거다.\n물론 코드내에서 folk 를 실행하면 실행하는 순간이 entry point 가 되는거고 말야.\n\n이와 마찬가지로, thread 역시 함수 단위로 entry point를 한번 싸준다(wrapping).\n코드 내 이곳 저곳에서 실행되는 folk 는 좀 지저분하잖아. 코드 보기 좆같아짐.\n쓰레드를 생성시키는 함수를 실행하면, 그 함수에 인자로 전달한 함수를 동시화 실행한단 말씀.\n그게 전부.\n대신 프로세스와 달리 하나의 프로세스에 할당된 메모리 공간 안에서 여러개의 쓰레드를 만들 수 있으니,\n전통적인 folk 와 달리 메모리 사용량이 늘지도 않고, pipe 따위 IPC를 뚫을 필요도 없고,\n전역변수나 인자로 전달된 포인터를 통한(구조체 따위의) 참조로 서로의 처리결과를 공유할 수 있다.\n\n다만, 여기서 발생하는 문제가,\n하나의 프로세서가 뒈져도 다른 프로세서엔 영향을 미치지 않는데 반해,\n하나의 쓰레드가 뒈지면 서로 메모리를 공유하는 쓰레드의 컨테이너, 즉 같은 프로세스 위에 도는 쓰레드는 다 나가 뻗게 된다는거.\n그래서 익스플로러 창 하나 뒈지면 바탕화면이 사라진다든지 (바탕화면도 하나의 익스플로러 쓰레드)\n하는 좆같은 상황들이 발생하는거지. 뭐 이정도 하면 쓰레드와 프로세스의 썰은 맺어도 되겠지 ㅇㅋ?\n\n\n7. 남은 주제들\n\n이제 겨우 어떤 이야기의 시작을 만든 것 같은데,\n운영체제란 과목을 들어보면 mutex 도 semaphore 도 자원의 접근 권한을 관리하기 위한 하나의 정수(int) 및 관련 연산일 뿐이다.\n즉, 개븅신 컴파일러가 제멋대로 최적화 해서 논리적인 오류를 만들어내지 않게 하기 위한 volatile 선언과\nif, goto 문만 사용해도 multi-tasking 을 지원해야 하는 운영체제가 가져야 할 기본적인 모든 기능을 만들 수 있어.\n하지만 아까 댓글에서 말했듯, 입출력을 감시해 동기화를 이루기 위해 while 문 따위 (if + goto) 를 돌린다면\n(내가 polling 구조라고 하는거) CPU 점유율이 증가하게 되고, 이를 손실없이 처리해주는 컴파일러+CPU 조합도 존재하긴 하고,\nsleep, yield 등의 함수들로 context switching 을 유도할 순 있지만, 고비용의 처리임은 틀림없지.\n그래서 IO 의 event 들을 비동기적(async) 으로 알려주는 함수들이 제공되는 거다.\n\n컨텍스트 스위칭이란 말 그대로 현재 작업중인 레지스터와 스택의 상태를 보존하고 다른 작업으로 넘어가는 것을 말하는데,\nsnap shot 의 개념이기도 하지.\n요즘은 VM 같은 sand-box - 샌드 박스도 뭐 보호메모리 구조랑 다를바는 없쥐 - 에서 복원점을 저장하는 것도 snap shot 이라고 부르긴 하는뎅,\n생긴 모양들이 다 거기서 거기 아냐?\n작게 작게 보든 크게 크게 보단 다 통신이고 다 context switching 이쥐.\n거기서 거기 그나물에 그밥. 와 운영체제 별거 없네.\n\n운영체제가 거대해 보여도,\n실상 해주는건 메모리 관리와 멀티태스킹을 위한 context switching, file system 지원, GUI 지원, API 준비, 장치 로더들, 계정 관리, shell 등 몇 가지 안돼.\n운영체제, 컴파일러 만들면 신, 이런게 아니라고... 70년대 이전에 만들어진 기술들이 뭐 대단한게 있을것 같냐?\n\n하고픈 말 대충 다 한 것같다.\n시부럴 별거 없구나. 미안.\n","btime":{"$$date":1478744802059},"mtime":{"$$date":1478744802059},"_id":"jC8DkmG2mMbqWysg"}
{"dirName":"codesafer","subName":"초보를 위한 강좌","fileName":"02. 저급언어, 고급언어를 사용한다는 것.md","fileData":"### 저급언어, 고급언어를 사용한다는 것.\n\n저급, 고급 언어의 정의는 시대적으로 다릅니다.\n기계, 즉 하드웨어 시스템과 얼마나 가까운 곳에서 작업하느냐의 분류에 따라\n고전적 정의에서는 어셈블리나 기계어가 저급언어, C 언어가 고급언어였지만,\n\n<- 저급언어                                     고급언어 ->\n[ Machine Code ][ Assembly ][ Pascal, C 등등등 ][ LISP ]\n\n지금은 보다 더 고급형 언어들이 속속 출현했기 때문에 ( 아래 숫자가 낮을수록 저급 언어 )\n\n1. [ Machine Code ][ Assembly ][ Pascal, C 등 address ( 포인터 )를 직접 다루는 언어 ]\n2. [ Java, C# 등 Garbage Colloector 가 있는 언어 ]\n3. [ Python, JavaScript 처럼 어지간한 것들은 이미 준비되어 활용과 조립만 신경쓰면 되는 언어 ]\n4. [ 함수형 언어 처럼 논리 체계 위주로 다루는 언어 ]\n\n로 표현되어 오히려 저급언어에 속하게 됩니다.\n\n본인이 이과 특성이 강하다면,\n저급언어인 C/C++ 이나 수학과 아주 유사한 함수형언어에서 출발하는게 재미있을 수 있습니다.\n양극성은 치밀한 계산과 시스템적 이해를 필요로하기 때문이죠.\n그런걸 알아야 재밌다고 느끼는 사람들이 이과적 특성이 강하다고 보여집니다.\n\n본인이 문과적 특성이 강하다면,\n2번과 3번쯤에서 골라잡으면 됩니다.\n무난한 이해와 논리에서 출발하는게 편안한 사람들이죠.\n\n결국은? 저 1,2,3,4 단계를 모두 정복하기 위해 확장을 시도하시게 됩니다.\n궁극에는 절대적으로 유리한 언어나 개념체가 존재하지 않아요.\n특별한 경우에 유리한 각각의 방법들이 존재할 뿐이거든요\n","btime":{"$$date":1478745988597},"mtime":{"$$date":1478746014653},"_id":"lofj8ALYz0kxmH3p"}
{"dirName":"codesafer","subName":"뻘소리","fileName":"공부 잘하는 법","fileData":"## 공부 잘하는 법\n\n근면 성실해야함.\n그래서 난 공부는 하기 싫어. ( 성적은 좋았다만 )\n난 삘이 안오면 꼼짝도 안하거든.\n\n대신 난 연구를 함.\n공부랑 연구랑 별 차이가 있겠냐만은,\n목표와 범위가 제한적이냐 아니냐의 차이겠지.\n\n공부는 군대에서 하는 구보와 같아.\n매일 매일 꾸준히 달리면 근력이 생기고\n같은 일을 할때 전혀 힘들이지 않게 돼.\n하지만, 앞 사람의 경로를 따라 뛰는건 사실 기력의 허비가 많아.\n앞 사람의 페이스는 나와 다르기 때문에,\n더 빨리 뛸 수 있는 상황에서도 숨죽이느라 힘들고,\n더 빨리 뛸 수 없는 상황에서도 따라가느라 overdrive 하게 되지.\n대열 옆으로 나와 자유롭게 뛰라고.\n\n공부든 연구든 지속성이 중요해.\n그리고 그뒤엔 영속성이란 과제가 남지.\n내 연구를 누군가는 받아주든,\n새로운 학문의 거름이 되어줘야 멸적을 면하니까.\n\n지속성을 높이는 방법은,\n일상에 연구를 mapping 시키는 방법이 좋은 것 같아.\n길을 가며 밥을 먹으며,\n흔히 이미 알려진 답이 나와있는 문제에 대해서도\n내가 추상화해둔 사고의 틀을 활용하는거지.\n\n누누히 말하지만 사람들은\n외워야할것과 이해해야할 것을 반대로 행하는 경우가 많다.\n그렇게 되는 이유는 short term / long term 등\n기억의 필요시간에 대해 적응하지 않기 때문인데,\n\n외어야 할 것은 단어나 공식이 아니야.\n문장이나 시츄에이션이지.\n왜냐하면 곱씹어 봐야하거든.\n그 결과 단어와 공식이 이해되고, 외어지는게 자연스러운거야.\n","btime":{"$$date":1478745788781},"mtime":{"$$date":1478745788781},"_id":"m98e0lTznZVGTPL1"}
{"dirName":"codesafer","subName":"뻘소리","fileName":"어깨가 아플때 해야 할 것","fileData":"## 어깨가 아플때 해야 할 것\n\n1. 베개 높이를 낮춘다.\n신선은 종이 한 장을 베고 잔다고 한다.\n평소 목이 앞으로 쏠리게 되는 개발자들의 자세 특성상 ( 모니터에 눈을 꼬라박느라 )\n뒤로 충분히 젖혀질수 있는 이완이 필요함.\n목만 받쳐서 1자목이 아닌 원래의 c자목이 ( c-spine ) 될 수 있도록 해주는 것이 요령.\n수건을 둥글게 감아 뒷목 약간 위에 베는 것도 방법.\n\n2. 자는 방향, 누워서 티비 (모니터) 보는 방향을 점검한다.\n한쪽으로만 자게되면 얼굴이 비대칭이 됨.\n우측 어깨를 깔고 자는게 심장에 편하긴한데, 어깨와 목에 무리를 줌.\n모니터에 영화같은걸 켜놓고 누워서 보다 잠드는 경우에도\n사실 아주 불편한 자세를 장시간 유지하게 되니\n누은 머리 위치를 자주 바꾼다든지해서 자세를 바꿔주는게 좋음.\n엎드려서 자는건 심장에 안좋음.\n정 엎드려야 되면 왼쪽 어깨와 다리 아래에 작은쿠션을 끼든지.\n\n3. 의자 높이 조절\n의자는 팔걸이가 책상에 겨우 들어가는 정도로 높은 높이가 좋음.\n허리가 뒤로 젖혀지는 의자들 매우 안좋아.\n단단히 고정된게 허리에 편해.\n물론 팔걸이 높이도 제각각인데,\n허리와 어깨에 들어가는 부하가 trade-off 관계라는것을 이해해야함.\n허리가 편하려면 팔꿈치->어깨로 상체를 지지해야 하고,\n어깨가 편하려면 허리에서 상체의 자중을 견뎌줘야 함.\n가장 win-win 하는 관계는 평소 운동으로 허리근육을 키워\n척추와 어깨 회전근에 주는 무리 ( 회전근개파열 ) 를 줄여주는 것임.\n\n4. 모니터 높이 조절\n시선의 높이가 수평보다 항상 높게 되면 ( 5도 이상 )\n목이 뒤로 약간 젖혀지게 되고,\n이 자세가 오래되는 경우에도 디스크가 발생함.\n따라서 거의 수평이 좋고,\n한 시간에 10분씩은 목을 부드럽게 돌려주는게 좋음.\n목이 뻣뻣하다고 강하게 젖히고 비틀고 하다가는\n목뼈가 갈려나가거나 목 근육이 탄력을 잃게 되니 조심.\n\n5. 혈류 점검\n건강검진시 피가 기름지게 나오는 사람들이나,\n선천성 질환인 혈색소이상처럼 혈전이 생기기 쉬운 사람들은\n피를 맑게 해주는 음식들 ( 양파, 마늘 따위 ) 을 충분히 먹어주고\n평소 물을 충분히 마셔야 함.\n그렇지 않으면 당뇨, 뇌졸중으로 진행가능.\n혈액순환이 잘 되지 않으면 한쪽팔, 엄지손가락까지 저리거나,\n어깨가 쉽게 결리는 현상이 나타난다.\n이러다 중풍으로 가 버리곤 하지.\n\n6. 수맥 ( 자기장 ) 점검\n피는 철분을 함유하고 있어 붉고 ( 산화 철 ), 철은 강자성체기 때문에\n혈류를 방해하는 요인으로 주택내의 자기 밀도 영향도 있음.\n휴대폰 앱 같은건 좀 엉망이긴 한데, 어떻게든 측정해서\n( 전용 계측 장비들은 구하기가 쉽진 않을듯 )\n가급적 자기장의 밀도 / 세기 변화가 큰 위치에선 잠을 자지 않는게 좋음.\n지반에 물이 흐르지 않아도 철골과 파이프, 보일러 배관 따위로\n자기장의 영향을 받을 수 있음.\n그래서 난 전기장판 같은거 싫어함.\n( 전자기파 관련한 품질 측정이 힘듦 )\n\n*. 배가 냉한 사람들이 허리를 쑤욱 아래로 내리는 식으로,\n혹은 상체를 책상 앞으로 쏠리게 하는식으로\n배를 책상에 닿게 하면 체온을 책상에 뺏겨 설사가 잦게 됨 조심.\n( 책상이 공기보다 열 전도도가 우수함 )\n이럴땐 배에 작은 쿠션 궈궈.\n\n이상은 내 오랜 경험에서 나온 컴퓨팅 하는 자세에서의 고려할 점들.\n허리 유연성 운동, 허리 근력운동, 달리기, 부드러운 스트레칭이 중요.\n","btime":{"$$date":1478745804811},"mtime":{"$$date":1478745804811},"_id":"pRzfqzCPyfONuV8g"}
{"dirName":"codesafer","subName":"C++ 초보를 위한 강좌","fileName":"07. 템플릿의 기본 문법","fileData":"## 템플릿의 기본 문법\n\n우리는 함수선언의 문법을\n``` cpp\nreturn_type function_name( arguments... )\n{\n    // to do\n}\n```\n이렇게 알아 왔다.\n\nfunction_name 이란 이름의 함수는\n괄호 안에 선언된 형식의 인자들을 이용해서 함수 내부에서 세부 조작이 가능하게 해 준다.\n( 어떤 동작의 주어, 목적어, 수식어 중 무엇이 올 수도 있다 )\n\n\ntemplate 문법에서는\n기존의 함수 선언에서 반드시 구체화 해야했던 [1. 타입]과 [2. 리터럴 상수]에 대해서도\n자리만 잡아 놓고 표현할 수 있다.\n\n유념 해야할 것은, 템플릿 확장 문법에 변수는 사용할 수 없다.\n컴파일 타임 ( constant time ) 에 결정되어야 하기 때문이다.\n그러니, 왜 템플릿 파라메터로 변수를 못넘김? 하고 울지마라. 바랄걸 바라야지.\n\n이미 다 구체화된 일반 함수와 달리,\n템플릿 함수는 실제 사용될 때, 사용된 예를 근거로 컴파일러가 알아서 치환해 준다.\n``` cpp\ntemplate< 자리만 잡아 둘 인자들 >\nreturn_type function_name( arguments... )\n{\n    // to do\n}\n```\n처럼 표현된다.\n\n\n템플릿 내부에 사용될 [1. 타입]의 경우,\n\n    1. typename\n    2. class\n\n    둘 중 하나의 키워드를 사용해 [임의의 타입]임을 알려야 한다. 둘 중 어느걸 써도 무방하다.\n    일단 난 줄맞추는걸 좋아해서 짧은걸 선호하게 되다 보니 class 를 쓰겠다.\n\n    template< class R, class T > // R 과 T 는 걍 타입입니다. int 고 double 이고 사용자 정의 구조체건 간에 말이쥬. 란 뜻\n    R function_name( T argument1 )\n    {\n        // to do\n    }\n\n    처럼 표현할 수 있다는 이야기.\n\n    위의 경우는 T 라는 타입이 function_name 을 실제 사용할 때 전달해주는 첫 번째 인자에 의해 컴파일러가 추론할 수 있다.\n    하지만 리턴 타입으로 쓰인 R을 추론할 수 없기 때문에,\n\n    fuction_name< void >( 0 );\n\n    처럼 사용해 주면,\n\n    void function_name( int argument1 )\n    {\n        // to do\n    }\n\n    라는 함수를 컴파일러가 자동으로 만들어 준다는 것이다.\n\n    이전 시간에 설명했지만 환기시켜주자면 c++컴파일러는 인자에 의한 다형성을 지원하기 때문에 사실상,\n\n    void function_name_int( int argument1 )\n    {\n        // to do\n    }\n\n    을 만들어준 셈이지.\n\n\n템플릿 내부에 사용될 [2. 리터럴 상수]의 경우,\n\n    1. null_ptr\n    2. 부동소수점 숫자\n    3. 리터럴 문자열\n\n    을 제외한 순수 상수 표현을 사용할 수 있다.\n\n    template< int LEVEL > // int 라고 했지만 이것은 리터럴( 말 그대로 ) 상수다.\n    void game_start()     // const int a = 변수; 처럼 사용된 임시 고정 상수가 아니란 말.\n    {\n        // game loop\n    }\n\n    처럼 표현될 수 있다는 이야기.\n\n    이경우, 사용할 때 LEVEL 에 해당하는 템플릿 인자를 넘겨 줘야 한다.\n\n    game_start< 5 >();\n\n    처럼 쓰면 된다.\n\n\n요약하면,\n템플릿 함수를 선언하기 위해 ( 템플릿 구조체나 템플릿 클래스도 마찬가지 )\n기존의 함수 선언이나 구조체, 클래스 선언 앞에 template< ... > 표현을 넣어주면 된다. 간단!\n그리고 템플릿으로 선언된 함수나 클래스를 호출하기 위해 필요한 템플릿 파라메터를 함수명이나 클래스명 뒤에 붙여주면 된다.\nfunction_name< ... >( ... );\n처럼 간단!\n\n즉, 템플릿 함수 호출에 있어서\n< ... > 는 컴파일 타임에 컴파일러로 하여금 코드 생성에 사용하도록 전달될 인자들,\n( ... ) 는 런타임에 전달될 인자들을 의미한다고 해석하면 된다.\n\n그러므로, 우리가 template 문법이 없던 시절\n```cpp\nvoid game_start1()\n{\n    const int LEVEL = 1;\n    ...\n}\n\nvoid game_start2()\n{\n    const int LEVEL = 2;\n    ...\n}\n\nvoid game_start3()\n{\n    const int LEVEL = 3;\n    ...\n}\n```\n처럼 구현 하던 것을,\n``` cpp\ntemplate< int LEVEL >\nvoid game_start()\n{\n    ...\n}\n```\n하나로 구현할 수 있게 되었고, 사용될때 알아서 game_start1, game_start2 ...\n얼마든지 만들어진다. 라고 생각하면 된다는 것!\n\n개편함!\n\n템플릿도 결국 함수의 다형성 처럼 이름이 다른 함수를 자동으로 만들어준다고 생각하면 된다.\nfunction_name< ... > 까지가 이름인것이쥐.\n내부적으론 functon_name_types..._constants... 처럼 이름이 만들어진다고 생각하면 되고 말야.\n","btime":{"$$date":1478742263741},"mtime":{"$$date":1478744540138},"_id":"qvW3aYqhkKXTEAin"}
{"dirName":"codesafer","subName":"C++ 초보를 위한 강좌","fileName":"09. 컨테이너 출력함수를 만들어 보자","fileData":"## 컨테이너 출력함수를 만들어 보자\n\n앞의 vector 출력문을 함수로 구현해 보자.\n\nvoid print( const std::vector< int >& some ) // '&' 참조기호를 사용한 이유는 스택에 복사하기 싫기 때문\n{\n    for( auto one : some )\n        std::cout << one << std::endl;\n}\n\n간단하지만, int 타입의 vector 밖에 사용할 수 없으니 답답하다.\n템플릿으로 일반화 하자.\n\ntemplate< class T >\nvoid print( const std::vector< T >& some )\n{\n    for( auto one : some )\n        std::cout << one << std::endl;\n}\n\n훌륭하다.\n하지만 vector 뿐만 아니라 다른 컨테이너들의 경우는 일일이 만들어주어야 한다.\n\ntemplate< class T >\nvoid print( const T& some )\n{\n    for( auto one : some )\n        std::cout << one << std::endl;\n}\n\n더 간단하고 더 효과적으로 일반화가 되었다.\n\n당연하게도 모든 컨테이너가 ranged for 나, std::cout 으로의 즉시 출력을 지원하지 않으니 만능은 아닐 것이다.\nranged_for 를 지원하기 위해서는 begin(), end() 를 비롯한 몇 가지 인터페이스를 구현해 주어야 한다.\n사용자 클래스들인 경우는 std::cout 으로의 출력을 지원하는 인터페이스도 만들어줘야 한다.\n\n여기서 더 일반화 할 꺼리가 무엇이 있을까?\n지금은 std::cout 으로의 콘솔 출력만 지원하는 셈이다.\n일반적인 output stream 에 모두 적용할 수 있도록 하고싶다면,\n\ntemplate< class T >\nstd::ostream& print( std::ostream& os, const T& some )\n{\n    for( auto one : some )\n        os << one << std::endl;\n    return  os;\n}\n\n처럼 구현하고 print( cout, some ); 처럼 호출해주면 된다.\nreturn 이 등장한 이유는 print( print( print( .... 처럼 직렬 표기를 가능케 하기 때문.\n\ntemplate< class T >\nauto& print( std::ostream& os, const T& some )\n{\n    for( auto one : some )\n        os << one << std::endl;\n    return  os;\n}\n\n요게 조금 더 깔끔하긴 하다.\n\n급식시절 논리에 대해 조금이라도 귀담아 들었던 사람은\n성급한 일반화의 오류를 기억할 것이다.\n\n이걸 줄이고 일반화해,\n\ntemplate< class T1, class T2 >\nauto& print( T1& os, const T& some )\n{\n    for( auto one : some )\n        os << one << std::endl;\n    return  os;\n}\n\n이렇게 한다면, 당신의 print 함수는 print( int, int ) 같은 기능을 추가 지원할 수 없게 된다.\n아이러니하게도 약간은 구체성과 제약을 갖는게\n정의간의 간섭을 줄일 수 있다는 것이다.\n\n여기다 연산자 오버로딩( 실은 오버라이딩 ) 을 끼얹으면,\n\ntemplate< class T >\nauto& operator+=( std::ostream& os, const T& some )\n{\n    for( auto one : some )\n        os << one << std::endl;\n    return  os;\n}\n\n이런 표현을 쓸 수 있다. 눈치 빠른 사람은 알겠지만 operator+= 까지가 이름이 되었고,\n사용할때만 += 이란 이름으로 쓸 수 있는 함수라고 생각하면 된다.\nstd::cout += some; 처럼 사용하면 된다.\n다만, 이경우 std::cout 에 원래 정의되어 있던 << 연산자와 우선순위가 달라지기 때문에,\n연속된 출력 연산의 경우\n순차가 될 수 있도록 연산자 우선순위를 고려해 괄호를 어딘가 싸줘야 할 것이다.\n\n연산자는 함수보다 더 일반화 된 형태기 때문에,\n논리적 충돌 가능성은 더 높다고 하겠다.\n알고 쓰면 좋지만, 정말 충돌이 없는 경우 맛깔스럽게 쓰는 정도가 정신건강에 이롭고,\n기존에 정의된 연산자 오버로딩이 있다면 가급적 사용하지 않는게 좋다.\n\n이제 한 가지 variation 이 남은것 같다.\n\n지금의 코드는 항목 하나 단위로 개행을 실시하고 있다.\n옆으로 나란히 붙여서 찍고 싶으면 어떻게 해야할까? ( 0 1 2 3 4 5... 처럼 )\n\ntemplate< class T >\nauto& operator+=( std::ostream& os, const T& some )\n{\n    for( auto one : some )\n        os << one << \" \";\n    return  os;\n}\n\n처럼 바꾸면 간단하지만, 다 출력한 후 마지막 스페이스가 거슬릴 경우가 있다.\n[ 0 1 2 3 4 5 ] 처럼 브라켓 '[' 와 멤버 사이에 한 칸을 띄우면 문제는 심플해진다.\n\ntemplate< class T >\nauto& operator+=( std::ostream& os, const T& some )\n{\n    os << \"[ \"; // 미리 한칸 띄었으니 제일 마지막 띄움이 등장해도 대칭이다\n    for( auto one : some )\n        os << one << \" \";\n    os << \"]\";\n    return  os;\n}\n\n하면 되잖아?\n\n그런데 아무래도 뒤의 공백을 없애고싶다면 ranged_for 를 포기하거나\n( 앞 강의의 iterator 참고, 마지막 한 개만 따로 찍기 )\n꼼수로 출력한 스페이스를 지우는 방법이 있겠다. ( 변태스럽다. 근데 답은 맞다 )\n\ntemplate< class T >\nauto& operator+=( std::ostream& os, const T& some )\n{\n    os << '[';\n    for( auto one : some )\n        os << one << \" \";\n    os << \"]\"; // 백슬래시 b 를 앞에 넣었다. 글에 안나올 뿐.\n    return  os;\n}\n\n어느쪽을 선호하든 여러분의 선택.\n여기도 일반화와 특수화의 개념이 포함되었다 하겠다.\n\n그런데 기왕 vector 가 나온김에 한 가지는 짚고 가자.\nvector< type > 에서, type 에 bool 이 해당하는 경우는, 다른 type 과 달리 특수한 경우다.\n보통 bool 은 1바이트 단위 자료형으로 선언이 되어 있지만,\nvector< bool > 은 메모리 공간 최적화를 위해 비트 단위로 저장된다.\n따라서 개수 단위로 위치가 지정되지 않기 때문에 begin(), end() 는 있지만\ndata() 인터페이스 자체가 없다.\n( 포인터로 쓰지마~ 우리 컨셉이랑 달라~ 란 뜻 )\n\n다음 시간엔 템플릿으로 수열을 제너레이팅해 보겠다.\n","btime":{"$$date":1478742284541},"mtime":{"$$date":1478744549273},"_id":"rOFy3mfFuEiIowY0"}
{"dirName":"codesafer","subName":"개념글","fileName":"lowlevel과 highlevel","fileData":"## low level 과 high level\n\n언어를 구별할 때도 사용되고 프레임웍이나 라이브러리의 지원 수준을 이야기 할 때도 사용된다.\n\n비슷한 용도로 사용되는 다른 표현으로는\nmicro 와 macro 가 있다. ( 째매한, 커다란 )\n\n마이크로 프로세서를 공부하게 되면 만나게 되는데,\n상대적인 개념이다.\n\n만약, 대입 명령을 ( 연산자를 ) CPU 내부에서 지원할 경우 ( 흔히 mov instruction 이라 부름 )\n누군가가, 임시 변수 T 를 이용해 A 와 B 의 값을 바꾸는 코드를\n다음과 같이 작성 했다고 가정하자\n\nT <- A\nA <- B\nB <- T\n\n여기서 대입명령 (<-) 은 micro 명령이다.\n위의 세 명령을 한 묶음으로 두 변수를 swap 하는 명령을 준비해 둔 시스템이라면,\nswap 은 macro 명령이다.\n\n수동카메라와 자동카메라 에서\n셔터스피드, 노출 등의 수동카메라 셋팅을 근접, 풍경, 인물, 야경 등의 묶음으로 해주는게 자동카메라.\n\nmanual transmission 과 auto transmission ( 자동차 수동, 자동 기어 변속기 )\n에서도 마찬가지의 개념이다.\n클러치를 밟고 기어를 풀고 기어를 넣고 클러치를 놓는 작은 명령들을 합쳐 놓은게 오토!\n( 덤으로 RPM, speed 판단 변속까지 )\n이것이 매크로의 개념이다.\n\nWindows API 는 저수준 함수, MFC 는 고수준 함수와 클래스를 제공해 준다.\n그래도 VCL 이나 .Net framework 앞에선 좁빱.\n\nDirect3D 는 OpenGL 에 비해 micro 명령들로 구성되어 있다.\nmicro는 쪼잔한 명령어나 함수들을 많이 불러야 의미로운 작업을 할수 있다는거지.\n\n대충 그림이 그려지지?\n\n굳이 설명을 하지 않아도 주변의 이런 경험들로 이해했을 친구들이 많을거라 생각한다.\n어쨌든 정리하면,\n\n로우레벨을 한다는건\n\n1. 디테일하게 커스터마이징 가능하다.\n2. 잘 다룰 경우 성능이나 연비효율( 배터리소모 등 )이 뛰어나다.\n3. 간단한 일을 할 때는 하이레벨에 비해 좀 더 귀찮은 노가다 작업이다.\n4. 초보에게는 진입장벽이 있다. ( 배경지식이 좀 더 필요하다 )\n5. 보다 원리를 깨닫게 되기에 정보의 소비자가 아닌 생산자의 입장이 되기 좋다.\n6. 하이레벨에서 지원해주지 않는 기능을 만들 수 있다.\n7. 그래도 하이레벨도 익혀두면 편하다.\n8. 때때로 하이레벨보다 간단해지기도 한다. ( remote desktop 을 구현하기 위해 마우스 이벤트를 전달하는 경우 )\n   로우레벨 -> mouse_down, mouse_move, mouse_up\n   하이레벨 -> mouse_enter, mouse_exit, mouse_drag, mouse_drag_drop, double_c+lick, mouse_c+lick, mouse_cancel\n\n는 것이다.\n","btime":{"$$date":1478742600865},"mtime":{"$$date":1478742600865},"_id":"u7oOr82SK8PCbVLJ"}
{"dirName":"codesafer","subName":"개념글","fileName":"C 언어 for 문 반복 비용에 관한 소고","fileData":"## C 언어 for 문 반복 비용에 관한 소고\n\n```\nvolatile int var = 1;\nfor( int i = 0; i < loop_count; ++i )\n    var += var;\n```\nN 번 iteration 하는 for 문 안에서 volatile 로 선언된 변수의 var += var 를 수행한 결과 그래프.\n역시 내가 만든 benchmark 환경은 깔끔한 그래프가 나온다. 히힣.\n\n추세선의 수식이 clocks( loop_count ) = 5.8 * loop_count - 68 의 형태로 계산되고 있다.\n-68 이 나오는 이유는 rdtsc 명령을 수행하면서 파이프라인과 스칼라에 묻힌 것. 무시하면 된다.\n\n0 에서 시작하는 기본 for 루프는 시작값과 반복조건 모두 상수인 경우는 3개의 명령으로 구성되지만\n지금은 loop_count 가 변수기 때문에 내부적으로 4개 명령어 조합으로 이루어진다.\n\n여기서 volatile 변수를 다루므로 값을 가지고 오고 다시 저장해야하기 때문에\nload, add, store 가 추가되어 7개 정도의 명령을 루프에서 수행하게 될것이다.\n\ndisassemble 해보진 않았지만 대략 다음과 유사한 구조겠지.\n\nloop_top:\n1. cmp iterator, loop_count //\n2. je loop_end              // for 는 진입 제어문\n\n3. mov eax, [&var]          // load var\n4. add eax, eax             // adder\n5. mov [&var], eax          // store var\n\n6. inc iterator\n7. jmp loop_top\nloop_end:\n\n여기서\n1 ~ 2 사이에는 cmp 결과가 write back 되는걸 기다려야 하니까 data dependency 존재.\n3 ~ 4, 4 ~ 5 사이에도 dependency 존재.\n6 ~ 1 사이에 dependency가 걸려 있게 된다. ( 어차피 jmp 에 의해 초기화 되지만 )\n\n즉 병렬화 가능한 부분은 2 ~ 3, 5 ~ 6, 6 ~ 7 사이밖에 없다.\n모두 최적화 된다면 단일 파이프라인 기준 7 - 3 = 4 클럭이 소요되어야 하지만,\ncache expire 에 의해 var 값을 새로 읽어오는 과정은 루프에 다른 명령들이 충분히 있으니까 묻히겠고\njmp(7.), cmp(1.), je(2.), 도합 세 개의 명령에 부가적인 작업이 발생했고\n4.8 클럭이 소요되었을 것이라 생각된다. ( 대략 1.6 * 3 )\n\n4 + ( 4.8 - 3 ) = 5.8\n","btime":{"$$date":1478742546843},"mtime":{"$$date":1478745625899},"_id":"w9XUFyVIJKtecBbp"}
{"dirName":"codesafer","subName":"뻘소리","fileName":"후회하지 말렴","fileData":"## 후회하지 말렴.\n\n어릴때 놀이터에서 동네 아이들과 야구를 하면,\n모래밭 위에 줄을 긋잖아?\n\n운동화에 모래가 들어갈 정도로 발을 질질 끌면서 긋는거지.\n\n나중에 학교에서 주전자에 물을 담아 부어 긋는걸 보면 신세경인데.\n알다시피 물은 volatile 해서 특히 햇볕짱짱한 날엔 금세 지워져버리지.\n\n줄을 긋다가, 그어놓은 줄을 되돌아보면 참 삐뚤삐뚤하다.\n그렇다고 뒤돌아선채 꼼꼼히 줄의 각도를 맞추며 후진하면,\n줄은 똑바른데 어딘가 다른 곳에 도착하게 되지.\n어쩔수 없어 사람 뒤통수엔 눈이 달리지 않은걸.\n\n어느쪽을 택하든 우스꽝스럽긴 마찬가진데,\n그 노력은 헛되지 않다.\n우리가 삐뚤삐뚤 그어놓은 줄 만큼, 우리는 놀이를 시작할 준비가 된거다.\n재밌을꺼야.\n세상 어디에도 존재하지 않는 다이나믹한 파울라인이 만들어졌으니.\n\n요령이 부족하다는걸 깨달았으면,\n다음엔 발을 끌면서 줄을 그을 때,\n다른 행동을 줄이고, 몸을 흔들지 않고\n똑바로 나가야겠다는 다짐 하나 가지면 된다.\n\n한가지 요령을 더 알려주자면,\n\n출발지점에 서서 목표지점까지의 직선을 눈에 넣은 뒤,\n그걸 대충 2~3 등분한 위치의 디테일을 눈에 넣어놓으면 milestone 이 된다.\n그 특징점이 분명해야 그 위치에 도달할 수 있는 것이고.\n남들이 똑같은 모래밭위 라고 보는 위치의 특징을 찾아내는것 또한 재능이다.\n\n재능있는 사람의 어제의 모습은\n오늘의 모습과 다를테니\n뒤돌아보고 스스로를 평가해 요령을 익힐 뿐,\n후회할 필요 없다.","btime":{"$$date":1478745834780},"mtime":{"$$date":1478745834780},"_id":"wJAyz0GuOxk0N1LD"}
{"dirName":"codesafer","subName":"C++ 초보를 위한 강좌","fileName":"03. 컴파일타임과 런타임","fileData":"## 컴파일타입과 런타임\n\n우리는 C/C++ 언어라는 컴파일형 언어를 이용해\n소스코드를 작성하고 컴파일러의 번역을 거쳐 실행파일을 얻게 된다.\n\n소스코드를 바로 line by line ( 혹은 statement 단위 ) 로 실행하는\ninterpret 형 언어에 비해\n오류없이 작성된 부분까지만이라도 실행해보는게 되지 않는 불편함은 있지만,\n오류위치까지의 실행시간이 긴 경우, 조금 더 빠른 평가가 가능하다는 부분과,\n실행중 해석이 적어 빠르다는 성능적 장점을 갖게되지.\n\n과거엔 constant 즉 상수에 대한 비중이 낮았다.\n\nconst 왜 써요? 타입을 명시할 수 있어서요~\n상수는 왜 써요? 컴파일러에 의해 최적화될 여지가 있어서요~\n이정도로 컴파일러에 떠넘기는식,\n약간의 syntactic sugar 수준으로 사용되어 왔다는 거지.\n\n그런데 modern c++ 에서는 추가 개선된 문법들을 통해,\n특히 template 을 통해 컴파일러를 좀 더 제어할 수 있게 되었다.\n\n말하자면,\ncompile time 과 대비되던 실행시간 ( run time ) 이란 개념이\nconstant run time ( 기존의 compile time )과\ndynamic run time ( 기존의 run time )\n으로 개념적 변화가 생겼다는거다.\n\n말이 조금 어렵지?\n\n우리가 template 과 constexpr 문법을 활용하면,\n컴파일러가 원하는 코드를 생성시키기 위한 프로그래밍을 할 수 있고,\n이 시점에서도 순차와 조건분기와 같은 절차적 프로그래밍을 할 수 있더란 것이지.\n\n다른 말로 표현하면,\n예전의 상수는 수치에 단위와 이름을 붙이는 행위 ( labeling ) 에 불과 했고,\n그 수치를 정하는 과정은 프로그래머의 머릿속 혹은 노트의 끄적거림 정도로 존재했지만,\n\n지금은 컴파일러에게 \"프로그래머의 상수 결정 과정을 프로그래밍\" 할 수 있는 환경이 되었다는 것이다.\n이것은 프로그래머의 생각과, 노트의 끄적거림이 재사용될 수 있는 경험이 되었다는걸 의미한다.\n담을 곳 없어 버려지는 가치있는 경험의 재활용. 이것은 아주 중요한 문제다.\n\ntemplate 과 constexpr 문법들을 통해,\n우리는 더 많은 암묵적 경험들을 명시적으로 표현할 수 있게 되었고,\n비슷한 중복 코드들을 효과적으로 제거할 수 있게 되었다는걸 말한다.\n\n대신, 그렇게 되기 위해서\n우리는 다시 한 번 constant time 과 run time 의 개념을 되새길 필요가 있다.\n\nSTL 에 있는 컨테이너를 조금 들여다본 사람들은\nstd::array\nstd::vector\n이 두가지가 있다는 정도는 이미 알고 있을 것이다.\n전자는 크기가 고정 ( constant, 픽스드 이거 영어로 안됨 ), 후자는 크기가 가변이다.\n\n그 말은 우리가 컴파일 타임에 결정해야 할 사안에 있어서는\nstd::array 를 활용할 수 있고,\nstd::vector 를 사용할 수는 없다는걸 말한다.\n\n또한, 실제로 존재하는 메모리가 필요한 type cast 문법들은 사용할 수 없다.\n( 사용하는 순간 run time 전용이 되어버린다 )\n\n이러한 constant time 이 가지는 제약을 개념화해 가져가면,\n여러분이 보다 편하게 이러한 문법들로 생각을 표현해나가는데 도움이 될것이라 기대한다.\n","btime":{"$$date":1478742118343},"mtime":{"$$date":1478744520706},"_id":"waorlnZ9SpOP27QA"}
{"dirName":"codesafer","subName":"C++ 초보를 위한 강좌","fileName":"08. STL 끼얹기","fileData":"## STL 끼엊기\n\n초보 강좌를 쓰기 위해서는 내가 초보가 되어야 한다.\n완전히 초보 입장에서 쓰지 못하면 인터넷에 널린 또 하나의 쓰레기가 되고 만다.\n솔직히 이런 글 적으면서 오글오글 거린다.\n역시 초보 강좌는 인내가 필요하다.\n시불 내가 언제 초보였더라...\n\n인터넷에 널리고 널린 자료들을 일일이 설명하는건 솔직히 시간 아깝다.\n아쉽지만 이 강좌만 본다고 초보딱지 떼지는건 아닐 것이다.\n이 시리즈는 연재속도가 빠를 수 없어서 복습용 정도로 보면 좋을 것 같다.\n다 떠먹여 주는 수준의 강좌는 엄청난 난이도가 될 것 같으니 말이다.\n그래도 노력중이란걸 알아주기 바란다. ( 어쩌면 초보 여러분 보다 훨씬 )\n\n대신, 내 강좌에 약속할 수 있는 것은,\n어느책에도 나와 있지 않은 나만의 해석, 해설, 비유가 녹아 있을 것이란 거다.\n\n*   *   *\n\n오늘은 STL 과 함께 하겠다.\n\nSTL 에는 데이타를 보관하기 위한 다양한 컨테이너를 제공한다.\n\n* 순차 컨테이너\n    1. 배열 ( array )\n    2. 동적 배열 ( vector )\n    3. 양방향 큐 ( deque )\n    4. 단방향 리스트 ( forward_list )\n    5. 양방향 리스트 ( list )\n\n* 연관 컨테이너\n    1. 정렬된 유일 key 집합 ( set )\n    2. 정렬된 유일 key 와 값의 집합 ( map ) - 별명은 dictionary 다. 사전처럼 쓰면 좋다.\n    3. 정렬된 중복허용 key 집합 ( multiset )\n    4. 정렬된 중복허용 key 와 값의 집합 ( multimap )\n\n* 비정렬 연관 컨테이너 ( ordered 는 sorted 와 같은 비슷한 의미다 )\n    1. 유일 key 해시 ( unordered_set )\n    2. 유일 key 와 값의 해시 ( unordered_map )\n    3. 중복허용 key 해시 ( unordered_multiset )\n    4. 중복허용 key 와 값의 해시 ( unordered_multimap )\n\n* 그밖에.\n    1. 스택 ( stack )\n    2. 큐 ( queue )\n    3. 우선순위큐 ( priority_queue )\n\n대충 이름보고 특징을 알 수 있는건,\nmulti 가 들어가면 중복을 허용한다는 것이다.\n\n유일 key ( unique key ) 라는건,\n보통 파일 시스템이나 데이타베이스에서 자세히 언급하게 되는데,\n\n원하는 데이타를 찾아가기 위한 검색 대상이 key 이고,\n주민등록 번호 같은것은 유일하니까 unique key 라고 부르지만,\n이름 같은건 유일하지 못하니까 ( 동명이인 ) 그냥 key 라고 부른다.\n위에 중복허용 이라고 적어놓은건 나의 에드립.\n\n그리고 set 은 키만 보관하는것,\nmap 은 key + 추가데이타 라고 보면 된다. ( std::pair 로 둘을 묶어서 사용한다 )\n\nunordered 는 정렬형태가 아닌 bucket 형태로 접근하기 때문에,\n정렬비용은 들지 않고 꽤 빠르게 찾아갈 수 있는 컨테이너다.\n자료구조에서 hash 를 참고하기 바란다. counter sort 나 radix sort 에도 개념이 나온다.\n\n여기선 대충 이런게 있다 정도만 알고 넘어가자. 레퍼런스에 잘 나오니까 각자 읽어보시고.\n예제에 사용할땐 사용되는 method 나 member 위주의 간단한 설명만 하겠다.\n\n*   *   *\n\n닥치고 소스가 등장한다.\n```cpp\n#include<iostream>\n#include<vector>\n\nint main()\n{\n    int a{ 0, 1, 2, 3, 4 };\n    std::vector< int > b{ 0, 1, 2, 3, 4 };\n\n    return  0;\n}\n```\n아직은 낯설지 모르지만,\n\nstd:: 란 접두사가 등장했다.\n지난 시간에 이야기했던 이름 뒤 <...> 기호도 등장했다.\n\n배운대로라면 ( scope operator ) :: 를 가진 std:: 는\n클래스/구조체/공용체/네임스페이스 들 중 하나일 것이다.\nstd 는 STL 에 포함된 기능들의 공통적인 namespace 다.\n\n이 std::vector 란 녀석은 STL 의 네임스페이스를 가진 템플릿이란 것이지.\n\n< int > 표현으로 타입을 지정했다는건,\nint 말고도 다양한 타입의 벡터를 만들 수 있다는 의미다.\n\nint 배열과 vector< int > 둘의 차이를 알겠는가?\n\n미리공부한 분들은 훌륭하다.\n전자는 크기가 고정된 배열이지만,\n후자는 push_back, emplace_back, insert 와 같은 멤버 함수를 사용해서 크기를 늘일 수도 있고,\npop_back, erase 들을 사용해서 줄어들게 할 수도 있다.\n\nb.emplace_back( 5 );\n\n같은 문법을 쓸 수 있다는거지. ( 그러면 b 는 0, 1, 2, 3, 4, 5 를 갖게 된다. )\n\n벡터는 크기와 방향을 가진 양 이란 뜻인데, 개인적으로는 부적절한 이름이라고 생각한다.\n동적 배열이라는 이름이 더 어울리고,\n많은 다른언어에서 dynamic_array 라는 이름을 사용한다.\n하지만 일단 스펠링이 짧으니 존중해주자.\n\nvector 는 미리 확보한 크기보다 크기가 커질 때, 스스로 메모리를 재할당( realloc ) 한다.\n그래서 성능은 순수 array 보다 느려지는 경우가 있을 수 있지만,\narray 를 제외한 다른 컨테이너 보다는 순차 및 임의 접근( random access ) 속도가 가장 빠른 편이다.\n그리고 약간의 최적화 요령이 있으면 array 와 비슷한 성능으로 사용할 수 있다.\n2 차원 3 차원으로 배열한다면 인접생성하지 않는 이상 느린건 어쩔수 없겠지만.\n( 어려운 이야기 해서 미안하다 넘어가자. )\n어쨌든, vector 는 써보면 무진장 편하다. 그걸로 존재의 가치는 충분.\n\n위의 소스코드는 뭔가 허전하다.\n단 하나의 출력코드도 없기 때문이다.\n\nmodern c++ 에서 추가된 ranged for 를 이용해서 간편하게 출력해 보자.\n\nfor( auto one : a )\n    std::cout << one << std::endl;\n\nfor( auto one : b )\n    std::cout << one << std::endl;\n\n이런식이면 된다.\n\nranged for 가 없던 시절에는\n```cpp\nfor( auto it = b.begin(); it != b.end(); ++it )\n    std::cout << *it << std::endl;\n```\n처럼 사용했다. ( auto 가 없던시절은 끔찍하니 패스 )\n\n여기서 전위형 단항연산자 ( unary operator : 피연산항이 하나라는 뜻 ) ++it 에 주목하자.\n\nfor 문의 마지막 절에서 ++it 를 하나 it++ 하나 보통은 성능 차이가 없다.\n기본 자료형들은 한번에 증가 연산을 할 수 있기 때문인데,\n구조체들(클래스포함)을 사용할때는 별개의 이야기가 된다.\n++it 는 자기 자신을 1 증가시켜서 그 자리에 놓게 되고,\nit++ 은 자기를 복사해서 그 자리에 놓고 자신은 그 후에 증가되게 된다.\n\nauto a = ++it; 는 이시점에서 it 와 a 가 같은 값이지만,\nauto a = it++; 에서는 a 와 it 의 값이 다르게 되는 이치다.\n\n그래서 iterator 라는 이름의 클래스로 만들어진 it는 it++ 표현에서 조금 더 느리다.\n\n설명이 길었지만 그냥 ++it 를 쓰는 습관을 들이자.\n\n감질나지만 이 강좌는 다음을 기약해야겠다. 분량이 좀 길어서 눈에 들어오지 않을게 염려되고,\n일단 강좌에서 STL 을 쓰기 시작할 염치를 마련했다는데 의의를 두겠다.\n","btime":{"$$date":1478742275520},"mtime":{"$$date":1478744544989},"_id":"y4aOd08R4X7r22Jt"}
{"dirName":"codesafer","subName":"개념글","fileName":"미술에서 말하는 구성의 3요소는 [ 변화 균형 통일 ] 이다.","fileData":"## 미술에서 말하는 구성의 3요소는 [ 변화 균형 통일 ] 이다.\n\n일명 변, 균, 통.\n3D와 사진술 에서 말하는 장면 구성의 3요소는 [ 대상(피사체), 조명, 시점(카메라) ] 이다.\n세 가지 요소들을 기억하고 코딩하렴.\n\n### [변화]가 없는 코드는 정보량이 적고, 정보량이 적다는건 줄여 나갈 가능성이 있다.\n함축적 모호성의 방향이 아니라, 요약적 명시성의 방향으로 진행할 때의 이야기.\n같은 일을 한다면, 짧은 코드가 유지보수가 쉽다. 만고불변의 법칙이다.\n게다가 적절히 자신만의 논리적 해법을 평이하지 않은 문법으로 표현한다면, 재미도 있다.\n밋밋한 코딩만 하면 땔감이기 딱 좋다. 자기 동기 부여도 부족해지고 말야.\n글 못쓰는 애들의 특징이 그렇잖아. 동어 반복. 어미와 조사들이 아주 단순화 되어 있지.\n그 미세한 차이들을 알고 잘 다루는 아이들의 글은 지겹지 않다.\n그나마 다행하게도 우리의 컴파일러와 CPU는 그런 단조로움들을 싫어하는 기색은 아니다.\n하루 종일 0과 1만 갖고 노는 애들이니. 하지만 우린 사람이잖아?\n\n### [균형]이 없는 코드는 모듈화가 덜 된 코드다.\n하나의 함수가 장황하게 길다는것 역시 명시성이 떨어진다.\n덩어리 코드 하나를 함수 하나로 묶어서 밖으로 빼주면\n짧아진 메인 바디만 읽어도 안에서 호출되는 함수의 이름들을 통해 흐름을 알 수 있는데,\n세부 코드를 모조리 다 읽게 만드는건 고문.\n즉 함수의 가치는 기능의 덩어리이며 요약이 가능한 양식이다.\n수없이 루프를 돌아야 하는 작은 코드를 함수화 하는건 비용이 비싸지만,\n(이럴 때의 대안이 #define 매크로 함수)\n큰 덩어리 하나 함수로 빼는데 드는 비용은 고작 4~6 클럭.\n\n### [통일]이 없는 코드는, 규칙성이 없어 명시적이지 않다.\n수많은 같은 값의 숫자 상수들이 쓰일때, 우리는 숫자 상수 하나 하나의 의미를 파악해야 한다.\n당연히 단어와 문장으로 의미를 설명하도록 매크로나 const 로 정의해 주는게 좋다.\n경험있는 프로그래머는 안다.\n반복 횟수니, 매개 수치와 같은 파라메터들은 결국 변수가 될 가능성이 높다는걸 말야.\nconst 형의 표현은 그런 상수의 변수화를 용이하게 한다.\n변수로 유지하는 것 보다는 상수로 유지하는쪽이 컴파일러가 최적화 할 가능성을 높여주니,\n굳이 변수를 고집할 필요는 없다. const 가 가장 좋은 대안.\n띄어쓰기, 개행, 들여쓰기 등의 규칙을 일관성 있게 유지하는 것도 명시성에 큰 도움을 준다.\n오타가 한 눈에 보이고, 논리적 규칙성이 보이며, 필요없는 nesting 을 쉽사리 감지하게 해 준다.\n","btime":{"$$date":1478744814297},"mtime":{"$$date":1478744814297},"_id":"yuRr5exL8WjBWeJs"}
{"dirName":"codesafer","subName":"초보를 위한 강좌","fileName":"03. 선언과 정의란","fileData":"### 선언과 정의란?\n\n선언( declaration )\n\n    선언이 프로그래밍 언어에 존재하는 이유는 세상속에서 선언이 갖는 가치와 같다.\n\n    구체화 하지 않은 수많은 약속들을 사람들 사이에 알리기 위해 우리는 선언을 활용한다.\n    예를 들자면, 만난지 한 시간도 안된 여성에게 다가가,\n\n    우리 사귀자! ( 동사를 바꾸면 19금 가능 )\n\n    이런 경우겠지.\n\n    공감할 컨텍스트가 있는 경우엔 ( 여성도 어지간히 외로웠다든지 ) 그게 또 통하는 경우가 있다.\n    특히 이런 상황은 어린 아이들 사이의 놀이에서 자주 등장한다.\n\n    우리 소꿉놀이하자!\n    구래!\n    내가 아빠고 네가 엄마야!\n    구래!\n\n    뭐 이런.\n\n    유치하지 않은가?\n    선언은 작위적이다.\n    하지만 효과적으로 협동할 수 있는건 사실이다.\n    당연히 배경지식이 거의 없는 바보 멍탱구리 컴파일러에게 협동을 요구할 때도, 선언은 유용하게 된다.\n\n\n정의( definition )\n\n    상대방도 협력의 의사를 표해 올 경우 ( 구래! ) 역할과 책임의 범위에 대한 정의가 필요해진다.\n\n    군데 아빠는 뭘 하는거고 엄마는 뭘 하는거야?\n\n    라는 질문에 답하지 않으면 아무것도 할 수 없다. ( 데꿀멍? )\n\n    이에 필요한 구체적인 사항들을 명백히 하는 것이 정의다.\n    하지만 막상 정의를 해 보면 그 정의 안에서도 수 많은 다른 개념들을 차용해야 한다.\n    이 때, 정의 안에서 또다른 세부 정의를 풀어쓰는 것 보다는,\n    선언된 다른 개념을 활용하는 것이 ( 호출 ) 효과적이라는 것.\n\n    아빠는 요리 재료를 찾아올테니까, 너는 요리를 해!\n    앙~ 군데~ 요리가 뭐야?\n    ( 슈발~ )\n\n    이래서 수준에 맞는 애랑 놀아야 된다.\n    그러니 다시 한 번 말하지만,\n\n    컴파일러에게 니 생각을 일일이 가르치기 귀찮으면 프레임웍을 써라.\n\n\n여러분이 살면서 얼마나 세련된 문장을 생활속에서 사용하는가?\n\n밥 먹자.\n고마 자자.\n공부 하자.\n개소리 그만해라.\n\n수준이지?\n\n프로그래밍도 별반 다를 바 없다.\n\n우리는 크게는 명사와 동사, 작게는 주어, 목적어, 동사 에만 집중해도 대부분의 일을 할 수 있다.\n약간의 수식어가 필요한 경우도 있지만 말이다.\n","btime":{"$$date":1478746002667},"mtime":{"$$date":1478746007936},"_id":"zINYjQtWI1jdB0Ee"}
{"dirName":"codesafer","subName":"C++ 초보를 위한 강좌","fileName":"01. API 와 STL 을 배워야하는 이유","fileData":"## API 와 STL 을 배워야하는 이유\n\n제가 모든 언어를 포괄해서 설명하는건 경제적이지 않으니까\n일단 제가 한창 작업중인 C++ 위주로 먼저 설명하는게 옳을 것 같습니다.\n\nC++ 언어는 다른 언어에 비해 설명이 많이 필요한 언어기도 하니까요.\nC 언어의 발생 시점에서도 그랬지만,\n좋은 책이 나오지 않았으면 AT&T 의 역사속에서 묻힐 수 밖에 없는 언어였습니다.\n\n익히 아는분들도 많을 이야기지만, C 언어는 크리스마스 장난처럼 만들어진 언어입니다.\n게임을 만들려니 어셈블리가 불편했고, 그래서 PASCAL, B, BCPL 을 베껴 뚝딱 만든게 C 언어,\n그 게임이 돌아가도록 운영체제가 필요했고, 그래서 AT&T 에서 말아먹고 있던 프로젝트인 MULTICS 에서\n복잡한 부분을 빼서 정리한게 Unix 란 운영체제 입니다.\n개발 동기에 대해 여러가지로 희화한 버전이 있지만 이정도로 알아두셔도 됩니다.\n\n컴퓨터의 역사에서 초창기에 만들어진 모든 것들은 사실 그다지 복잡하지 않습니다.\n오히려 간결하기 때문에 처음엔 어렵게 여겨질 수 있는 정도지요.\n\n앞서 include 없이 printf 구현하기란 글에서 언급했지만,\nC 언어의 문법 그 자체는 램 말고는 하드웨어를 건드릴 수 있는 여지가 없습니다.\n따라서, 표준 라이브러리를 통해 운영체제가 제공해주는 API ( Application Programming Interface ) 를 사용해야만\n화면에 무언가를 찍을 수 있고, 키보드나 마우스로 부터 무언가를 입력받을 수 있습니다.\n\n더 더 lowlevel 로 내려가서 본인이 직접 구현할 수 있습니다.\nBIOS 를 직접 제어하든, 심지어 CPU를 직접 설계할 수도 있죠. ( FPGA 같은걸 통해서 손쉽고 저렴하게 )\n하지만 그게 실용적인 목적을 가지고 있지 않다면 지속하기는 힘든 작업이겠죠?\n\nAPI 는 운영체제를 개발하는 개발사에서 만들고 손보게 됩니다.\n표준 라이브러리는 컴파일러를 개발하는 개발툴 제작사에서 만들고 손보게 됩니다.\n그 말은, 새로운 하드웨어가 등장하고 스펙이 변화되면, 그 변화를 다른사람들이 책임지고 손봐서 적용해 준다는 이야기죠.\n그래서 바퀴를 재발명 하지말라는 이야기가 있습니다.\n가끔은 바퀴를 리뉴얼 할 필요가 있긴 하지만요 :)\n\n즉, 본인이 하드웨어의 변경점 마다 모든걸 다시 개발할 의지가 없다면, 있는걸 잘 써주는게 필요합니다.\n있는게 자기의 요구사항을 충족시켜 줄 경우 말이죠.\n\n그래서 API와 표준 라이브러리는 잘 알고 써먹을 수 있으면 좋은 것입니다.\n\n그러면 STL 은 왜 배워야 할까요?\n\n이것도 표준 라이브러리기 때문입니다.\n초창기 STL은 아주 열악한 성능과 버그에 의해서 응용개발자들의 큰 호응을 끌어낼 수 없었습니다.\n지금은 다른 개발 도구들의 성능이 좋아지면서, 좀 더 품질 좋은 컴파일러를 만들어낼 수 있게 되었고,\n상호 상승작용을 거쳐 꽤 쓸만한 라이브러리로 바뀌었죠.\n\nSTL 이 없는 C/C++ 언어는 알고리즘에 관해 거의 문외한 수준이어서\nqsort 나 binary_search 를 들들 볶아\n자기 용도에 맞게 바꾸는 작업이 꽤 불편하고,\n한 가지 타입에 종속적이어서 매 프로젝트마다 새롭게 구현해 줘야 하는 경우가 많았거든요.\ntemplate 라는걸 통해서 한 가지 타입에 특정되지 않고, 여러 타입에 일반적인 문법을 사용할 수 있게 된데다,\nSTL 을 통해서 타입 / 컨테이너 / 알고리즘을 분리시켜 하나씩만 구현해도 여러 조합의 경우를 포괄할 수 있는\n언어가 된거죠.\n\n지금의 C++ 언어는 언어 자체를 변경하는 부분의 부담을 덜기위해\nSTL 을 통해 확장하는 형식으로 발전하고 있습니다.\n\n그래서 STL을 배워야 하는 것이죠.\n","btime":{"$$date":1478741981419},"mtime":{"$$date":1478744508858},"_id":"zbQkIFYK9Il52uf2"}
