의미를 전달할 수 있는 변수 이름을 붙여 주세요
-> 당연

매직 넘버에는 이름을 붙여주세요
-> 물론 가급적 모든 상수엔 이름을 붙이는게 좋습니다. 이터레이터의 0, 1 정도가 가끔 예외
-> 상수는 변수와 달리 오히려 강한 의미를 갖고 있습니다.
-> 그래서 네이밍하기도 편하고 네이밍 해두면 소스코드가 사람말에 가깝게 읽혀지게 되죠.

복잡한 조건식은 함수화해주세요
-> 어디를 자르느냐가 관건. 조건에도 의미가 있습니다. 그 의미를 따서 함수명으로 사용하면,
-> 조건을 해석해서 의미를 파악하는게 아니라 그냥 읽으면 되죠.

계산식을 함수화해서 의미를 전달하세요.
-> 계산식에 이름을 붙이다 보면 유사한 유형들이 하나로 통합 정리되어 가고,
-> 재사용성을 높일수 있을 뿐더러, 역시 사람말로 읽을 수 있는 코드가 됩니다.
-> 컴파일러가 좋아지니 주저할 필요 없습니다. 가장 단순하고 직관적인 단어를 찾아 이름을 붙이세요.

사전 조건과 사후 조건은 assert로 명시해주세요.
-> 이런 일이 있어선 안돼! 를 명시하기 좋습니다.
-> 만약 프로그램 실행을 더이상 진행했다간 큰일이 날 것 같을 땐 가차없이 그만둬야죠.
-> 피가 퐁퐁 솟아나는데 수술을 계속할 순 없는 일.
-> 예기치 않게 데이타 파일을 깨먹는다든지 엉뚱한 패킷을 날려서 계좌가 털려버릴 수도 있으니까요.

사소한 중복도 티끌모아 태산이 되므로 줄여주세요.
-> 동어반복과 중복의 제거는 성능과 재사용성,
-> 관리의 유용성 ( 관리포인트의 단일화 ) 를 위해 필수적인 요소입니다.

조기 리턴을 활용해 주세요.
-> 함수 안에서 if ( ... ) return; 을 사용하면 불필요한 들여쓰기를 줄일 수 있습니다.
-> 배제할 수 있는 조건의 우선 배제는 뒤에 실행되는 코드의 논리를 가볍게 합니다.
-> 일찍 처리할 수 있는 일 부터 끝내고 노는게 여러가지 일을 양 손에 들고 고민하는 것 보다 편하죠.
-> break, break 릴레이 하는 것에 비해 나은 성능을 발휘 할 수 있습니다.

if 조건문을 작고 단순하게 만들어주세요.
-> 당연히 성능과 직관적 읽기, 논리적 허점을 줄이기 위해서 불필요한 논리의 열거는 지양해야합니다.

자료구조를 활용해서 if 조건문을 줄여보세요.
-> 무분기 의 장점은 흐름을 단일화 하고, 파이프라인 효율을 높이게 해 줍니다.
-> 다만 가끔 if 한개가 깔끔하고 성능도 빠른 경우가 있으니 집착할 필욘 없습니다.

null을 체크하지 않아도 되는 방법을 생각해보세요.
-> 보통 null 을 체크하는 경우는 두 가지죠. 객체의 소멸 시점이 복잡한 경우,
-> 루프 안에서 복수개의 조건이 존재하는 경우.
-> 이때 객체의 소멸 시점을 보다 근본적으로 일괄 관리할 수 있도록 구조를 고민하는게
-> 뒷처리하는것 보다 튼튼한 구조입니다.
-> 문자열 함수처럼 루프 안에 존재하는 여러 조건들이 null 을 만날때 까지 무한히 돌아야 하는 경우는 드뭅니다.
-> strncpy 같은게 있는 이유는 안정성을 높이기 위해서죠.
-> 반대로 두개 이상의 논리적 조건이, 하나의 더 빠른 논리적 조건에 가려질 수 있을 때,
-> 빠른 조건을 선택하는게 당연히 성능에도 좋습니다.
