## C/ C++ 에서 전역변수 사용의 득과 실

1. 전역 변수는 프로그램의 실행 시점에 생성되어서 종료시점에 해제됨.
2. 지역 변수는 함수의 실행 시점에 생성되어서 함수의 종료시점에 해제됨.
3. static 으로 선언된 지역 변수 ( 정적 변수 ) 는 전역 변수와 같음.
다만 이름이 노출되는 범위만 지역에 한정됨.

그말은, 전역 변수는 사이클 전용트랙 같은 경기장이고,
지역변수는 걍 운동장이란거야. 니들이 공연을 하든 축구를 하든, 육상대회를 하든
그때 그때 원하는 용도로 메모리라는 자원을 사용가능하다는거지.
전역변수는 용도 변경이 힘든 메모리 라는거고.

하지만, 전역으로 선언한 자원의 용도 변경이 완전히 불가능한 것은 아니야.
C++ 은 포인터를 사용할 수 있고, 포인터의 캐스팅이 그걸 가능하게 해주지.

그래서 넓은 자원을 전역으로 할당해 놓고 memory pool 로 활용할 경우는
변수 단위로도 구조체 / 클래스 단위로도 접근할 수 있어서 용도 변경이 가능해.

본질적으로 보면, 램은 유한자원이고,
컴퓨터가 부팅된 후 실행시간에 램을 늘이고 줄일 방법이 존재하지 않기 때문에,
사실상 정적 메모리고, byte 단위로 주소 지정가능한 전역메모리라고 볼수 있어.

그걸 메모리 풀처럼 할당 해제해주는 기능을 OS 가 대신하고 있을 뿐이지.
malloc 과 free, new 와 delete 와 같은 동적할당 메카니즘을 통해서 말야.

하지만 전역변수가 동적 할당 메카니즘에 비해 유리한 경우가 있어.
그건 바로 memory fragmentation - 메모리 단편화 - 로 부터 자유롭다는거지.

만약 누군가가
[A][B][A][B]
이렇게 4개의 블럭을 동적 할당해서 사용하다가
B 들을 다 해제 했다면
[A][_][A][_]
가 되어서 두 블럭이 사용가능해져.
하지만 이때, 블럭 두개짜리 를 한 번에 할당하려고 하면 할당이 안돼.
동적 할당은 논리적으로 연속한 메모리만 허용하거든.
( 주소 선형성을 만족하는 = 주소가 인접한 메모리 끼리 )

이걸 메모리 단편화라고 해.

이 문제를 해결하기 위해서 memory compaction 을 구현하는 경우가 Java 나 C# 의
Garbage collector 야.
[A][_][A][_] 를
[A][A][_][_] 가 되게 옮겨 주는거지.
