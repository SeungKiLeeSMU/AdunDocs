## 컴파일타입과 런타임

우리는 C/C++ 언어라는 컴파일형 언어를 이용해
소스코드를 작성하고 컴파일러의 번역을 거쳐 실행파일을 얻게 된다.

소스코드를 바로 line by line ( 혹은 statement 단위 ) 로 실행하는
interpret 형 언어에 비해
오류없이 작성된 부분까지만이라도 실행해보는게 되지 않는 불편함은 있지만,
오류위치까지의 실행시간이 긴 경우, 조금 더 빠른 평가가 가능하다는 부분과,
실행중 해석이 적어 빠르다는 성능적 장점을 갖게되지.

과거엔 constant 즉 상수에 대한 비중이 낮았다.

const 왜 써요? 타입을 명시할 수 있어서요~
상수는 왜 써요? 컴파일러에 의해 최적화될 여지가 있어서요~
이정도로 컴파일러에 떠넘기는식,
약간의 syntactic sugar 수준으로 사용되어 왔다는 거지.

그런데 modern c++ 에서는 추가 개선된 문법들을 통해,
특히 template 을 통해 컴파일러를 좀 더 제어할 수 있게 되었다.

말하자면,
compile time 과 대비되던 실행시간 ( run time ) 이란 개념이
constant run time ( 기존의 compile time )과
dynamic run time ( 기존의 run time )
으로 개념적 변화가 생겼다는거다.

말이 조금 어렵지?

우리가 template 과 constexpr 문법을 활용하면,
컴파일러가 원하는 코드를 생성시키기 위한 프로그래밍을 할 수 있고,
이 시점에서도 순차와 조건분기와 같은 절차적 프로그래밍을 할 수 있더란 것이지.

다른 말로 표현하면,
예전의 상수는 수치에 단위와 이름을 붙이는 행위 ( labeling ) 에 불과 했고,
그 수치를 정하는 과정은 프로그래머의 머릿속 혹은 노트의 끄적거림 정도로 존재했지만,

지금은 컴파일러에게 "프로그래머의 상수 결정 과정을 프로그래밍" 할 수 있는 환경이 되었다는 것이다.
이것은 프로그래머의 생각과, 노트의 끄적거림이 재사용될 수 있는 경험이 되었다는걸 의미한다.
담을 곳 없어 버려지는 가치있는 경험의 재활용. 이것은 아주 중요한 문제다.

template 과 constexpr 문법들을 통해,
우리는 더 많은 암묵적 경험들을 명시적으로 표현할 수 있게 되었고,
비슷한 중복 코드들을 효과적으로 제거할 수 있게 되었다는걸 말한다.

대신, 그렇게 되기 위해서
우리는 다시 한 번 constant time 과 run time 의 개념을 되새길 필요가 있다.

STL 에 있는 컨테이너를 조금 들여다본 사람들은
std::array
std::vector
이 두가지가 있다는 정도는 이미 알고 있을 것이다.
전자는 크기가 고정 ( constant, 픽스드 이거 영어로 안됨 ), 후자는 크기가 가변이다.

그 말은 우리가 컴파일 타임에 결정해야 할 사안에 있어서는
std::array 를 활용할 수 있고,
std::vector 를 사용할 수는 없다는걸 말한다.

또한, 실제로 존재하는 메모리가 필요한 type cast 문법들은 사용할 수 없다.
( 사용하는 순간 run time 전용이 되어버린다 )

이러한 constant time 이 가지는 제약을 개념화해 가져가면,
여러분이 보다 편하게 이러한 문법들로 생각을 표현해나가는데 도움이 될것이라 기대한다.
