## low level 과 high level

언어를 구별할 때도 사용되고 프레임웍이나 라이브러리의 지원 수준을 이야기 할 때도 사용된다.

비슷한 용도로 사용되는 다른 표현으로는
micro 와 macro 가 있다. ( 째매한, 커다란 )

마이크로 프로세서를 공부하게 되면 만나게 되는데,
상대적인 개념이다.

만약, 대입 명령을 ( 연산자를 ) CPU 내부에서 지원할 경우 ( 흔히 mov instruction 이라 부름 )
누군가가, 임시 변수 T 를 이용해 A 와 B 의 값을 바꾸는 코드를
다음과 같이 작성 했다고 가정하자

T <- A
A <- B
B <- T

여기서 대입명령 (<-) 은 micro 명령이다.
위의 세 명령을 한 묶음으로 두 변수를 swap 하는 명령을 준비해 둔 시스템이라면,
swap 은 macro 명령이다.

수동카메라와 자동카메라 에서
셔터스피드, 노출 등의 수동카메라 셋팅을 근접, 풍경, 인물, 야경 등의 묶음으로 해주는게 자동카메라.

manual transmission 과 auto transmission ( 자동차 수동, 자동 기어 변속기 )
에서도 마찬가지의 개념이다.
클러치를 밟고 기어를 풀고 기어를 넣고 클러치를 놓는 작은 명령들을 합쳐 놓은게 오토!
( 덤으로 RPM, speed 판단 변속까지 )
이것이 매크로의 개념이다.

Windows API 는 저수준 함수, MFC 는 고수준 함수와 클래스를 제공해 준다.
그래도 VCL 이나 .Net framework 앞에선 좁빱.

Direct3D 는 OpenGL 에 비해 micro 명령들로 구성되어 있다.
micro는 쪼잔한 명령어나 함수들을 많이 불러야 의미로운 작업을 할수 있다는거지.

대충 그림이 그려지지?

굳이 설명을 하지 않아도 주변의 이런 경험들로 이해했을 친구들이 많을거라 생각한다.
어쨌든 정리하면,

로우레벨을 한다는건

1. 디테일하게 커스터마이징 가능하다.
2. 잘 다룰 경우 성능이나 연비효율( 배터리소모 등 )이 뛰어나다.
3. 간단한 일을 할 때는 하이레벨에 비해 좀 더 귀찮은 노가다 작업이다.
4. 초보에게는 진입장벽이 있다. ( 배경지식이 좀 더 필요하다 )
5. 보다 원리를 깨닫게 되기에 정보의 소비자가 아닌 생산자의 입장이 되기 좋다.
6. 하이레벨에서 지원해주지 않는 기능을 만들 수 있다.
7. 그래도 하이레벨도 익혀두면 편하다.
8. 때때로 하이레벨보다 간단해지기도 한다. ( remote desktop 을 구현하기 위해 마우스 이벤트를 전달하는 경우 )
   로우레벨 -> mouse_down, mouse_move, mouse_up
   하이레벨 -> mouse_enter, mouse_exit, mouse_drag, mouse_drag_drop, double_c+lick, mouse_c+lick, mouse_cancel

는 것이다.
