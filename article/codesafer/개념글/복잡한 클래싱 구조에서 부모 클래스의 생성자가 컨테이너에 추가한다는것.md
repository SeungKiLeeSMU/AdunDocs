## 복잡한 클래싱 구조에서 부모 클래스의 생성자가 컨테이너에 추가한다는것.

``` cpp
class SOME_OBJECT ... // 추상 클래스

// AddChild 멤버함수를 갖고 destructor 에서 Children 을 삭제하는 역할 담당.
// Singleton 일 수 있음.
class CONTAINER : public SOME_OBJECT ...

CONTAINER* container; // 할당되어 있다 치자

class PARENT : public SOME_OBJECT
{
public:
    PARENT( SOME_OBJECT* owner )
    {
        owner->AddChild( this );
    }
};

class CHILD : public PARENT
{
    using inherited = PARENT; // 이러면 super 처럼 쓸 수 있음
public:
    CHILD( SOME_OBJECT* owner ) : PARENT( owner ){} // 자식 클래스들을 만들때 마다 부모로 릴레이
};

**** N 개의 child class 를 추가 개발하면서 container 에 대해 알 필요가 없음
**** 오로지 부모 생성자 초기화 만으로 새로운 클래스 참여 완료.

//////////////////////////////////// 여기까진 프레임웍 개발 타임
여기서부터 가져다 쓰는 시점 ////////////////////////////////////

1. 가져다 쓸때 CHILD 의 다른 프로퍼티를 건드릴 필요 없으면
new CHILD( container );

2. 다른 프로퍼티에 접근해야 할 때
CHILD* child = new CHILD( container );
child->blahblaa...
child->blahblaa...

**** 1. 2 두 케이스 모두 생성자와 container 라는 이름만 접근.

///////////////////////////////////////////////////////////////////////////////////////

아래는 이렇게 구현되어 있지 않을 경우.

1. 가져다 쓸때 CHILD 의 다른 프로퍼티를 건드릴 필요 없으면
container->AddChild( new CHILD );

2. 다른 프로퍼티에 접근해야 할 때
CHILD* child = new CHILD;
child->blahblaa...
child->blahblaa...
container->AddChild( child );

**** 1. 2 두 케이스 모두 생성자와 container 라는 이름 외에 AddChild 라는 멤버함수를 기억+사용해야 접근.
```

어느쪽이 더 편하냐? ( 대소문자 까지 기억해야 되면 더 귀찮지 )

두 코드의 기능에 차이가 있냐? No
손품은 후자가 더 팔지? Yes

어느쪽을 선택하든 자유야. 동작도 같아. ㅉㅉ
난 커졌을 때 손 덜가고 기억 덜하는 코드를 택하겠다 이거야.
