## 멀티쓰레딩, 멀티테스킹, 멀티프로세싱, 멀티프로그래밍, 멀티코어란?

0. 모든 처리(process)는 통신, 즉 장치(device, equipment), 작은 단위의 장치들로 큰 단위의 장치를 이루는(unit) 블럭들 간의
communication 의 과정이다.

1. 멀티프로세서와 멀티코어, 그리고 채널, 또한 DMA, 그리고 co-processor

흔히 아는 사실이지만, 이건 관습적인 이슈다.
아주 오랜 옛날 코세가 담배 배우기 전, 혹은 태어나기 전,

CPU(Central Processing Unit : 중앙 처리 장치)는 계산하기도 바빴기 때문에(너무 느려 느려~),
입력과 출력을 담당하는 별도의 프로세서가 필요했다.
그걸 Channel 이라고 불렀다. 요즘은 그 관습이 이어져 DMA(Direct Memory Access) Channel 이란 표현을 쓴다.
CPU 에게 부담을 주지 않고 주변장치가 메모리에 직접 접근(Access : Read & Write)하는 방식을 이야기 하는 것이지.

초기에는 하나의 반도체 chip 을 하나의 패키지에 담고 Processor 라고 불렀고,
하나의 메인보드 위에 여러개의 패키지를 장착할 수 있게 하는것을 Multi Processor 라고 불렀다.

그러다, 집적도가 높아지면서 하나의 패키지에 여러 chip 을 담기 시작했고, 그걸 Multi core 라고 부르게 되었는데,
지금은 그 경계가 모호하지. 하이퍼 쓰레딩에서 논리 코어로 나눠버리기도 하고 말야.

또한 이미 출시된 프로세서의 부족한 연산능력을 보완하기 위해 보조 프로세서가 등장하게 되었다. (흔히 알고 있는 80x87 시리즈)
주로 부동소수점 연산을 보조하게 되었는데, 486 부터는 FPU(부동소수점 연산 장치)가 chip 에 통짜로 구워지게 되었고,
co-processor 라는 개념이 사라지기 시작했지. 지금은 DSP 같은 것들이 병렬 파이프라인과 SIMD,
더 큰 단위의 수학적 계산 명령어들을 담고 있다.


2. Interrupt, IRQ, PIC

CPU 와 주변장치들이 독립적으로 구동되면서 주변장치에 일일이 프로세서를 할당해 통신하는 비용을 줄이기 위해,
PIC 라는 구조를 채용하게 되었다. Programmable Interrupt Controller 라는 거지.
여러 사건들을 인터럽트로 가공해 제어하는데, 프로그램으로 제어할 수 있게 만들겠다는거여.
어찌되었건 PIC 의 실체는 전통적으로 메인보드에 달려 있는 칩셋 하나다. (8259A 칩)

물론 예외적으로 NMI 가 있다. (Non-maskable Interrupt)
난 NMI를 알기 전에 PC의 IRQ 목록을 보면서 0번은 타이머구나 1번은 키보드구나... 이런식으로 이해했기 때문에
(책을 보고 공부한게 아니라 말이지)
아하~ 가장 중요한건 시간/시각 이다. 라고 생각했었음. (물론 클럭 동기화가 필요한 칩셋의 구조상 틀린 말은 아닌데)
나중에 컴공에서 수업을 들으며 NMI 즉, 인터럽트 서비스 루틴을 가로챌수 없는 인터럽트가 전원 관련 이슈라는걸 배우게 되었지.
이제 전원떨어진다~ 같은건 건들지 말란 소리임. 워낙 크리티컬 해서 UPS(무정전 전원 장치) 같은 고비용의 장치가 있던 시절이니까 말야.
(UPS - battery - built-in 인 노트북 짱짱맨~)
그래서 Unix 계열 운영체제는 실행중인 시스템의 보호를 위한 여러가지 정책을 갖고 있다.
배터리 로우나 전원 떨어짐 같은(캐패시터로 버티는 잠시간의 시간동안) 이벤트에 하드디스크에 백업할지 버릴지 그런 것들 말야.
어쨌든, PIC 는 인터럽트 마다 우선순위를 두어(IRQ) 요청을 처리하게 된다.


3. Multi tasking

정보통신공학개론 같은걸 들어보면, 분할 다중화 방식에 대해서 이야기 한다. (Division Multiple Access)
즉, 하나의 매체, 통로(bus)를 이용해 여러가지 처리를 하는 방식을 논하는 것으로,
FDMA (Frequency ~ : 주파수 분할 다중화 방식), TDMA (Time ~ : 시분할), CDMA (Code ~ : 코드분할) 을 이야기 하지.
FDMA는 주파수로 구분된 AM/FM 라디오를 생각하면 편할테고,
TDMA 는 주로 유선 전화교환망,
CDMA 는 무선 전화기를 떠올리면 됨.

CPU에선 무선따위가 없으니 다중화를 위해 TDMA 를 구현하게 된거고,
time slot 을 잘게 쪼개 여러가지 일을 동시에 수행하게 한거다.
과거 8비트 APPLE 시절에 믿을 수 없는 4중 화음! 이라고 광고한 소프트웨어는
TDMA 를 통해 FDMA 를 에뮬레이션 한거라 볼 수 있지.
오늘날의 마이크와 스피커도 마찬가지 구조고 말이야. -> 신호처리에서 nyquist frequency 로 이어지는 이야기다.

고전적으로는 인터럽트가 발생하면 처리하던 절차적인 작업을 잠시 중단하고, 다른 작업을 하고 오는 수준으로
빠르게 스위칭 하는걸 multi tasking 이라고 하지만 말야.
(그래서 Instruction Fetch Cycle 을 개념적으로 나눌 때 Interrupt 처리를 넣기도 하고 안넣기도 하지)


4. Multi processing

어느덧 운영체제에서 multi tasking 을 지원하고, 하드웨어에서도 지원하게 된다.
자꾸 동시성에 대한 요구들이 나오니까 말야.
하드웨어에서 CPU를 여러개 장착하는건 굳이 구구절절 설명할 여지가 없겠다.
심지어 하나의 장비에 여러 메인보드, 여러 운영체제를 박는 경우도 있긴 해. ETS 같은 장비들이지.

여기서 동시성을 주의깊게 생각해 볼 필요가 있겠다.

두 친구가 취직을 위해 서울에 상경했다고 생각해 보자.
야 너 값싼 방 좀 알아봐. 나도 좀 알아 볼 께.
이런 경우는 한 가지 일을 나눠서 하는 경우지.
이때 주의할 점이 뭐겠냐?
둘 다 같은 방을 알아보고 있으면 낭비란거지. -> 그래서 보통 같은 일을 할땐 구역을 나눈다. ->
니가 신설동을 뒤져 내가 제기동을 뒤질게 이런식.

또한, 식당의 예를 생각해 볼 수 있겠지.
마스터 쉐프가 다른 동료들에게 재료를 다듬어 데쳐올 것을 요구한다 치자.
각자 일을 하다가. 재료는 준비되었나? 물어보겠지.
그리곤 task 가 합쳐지는거다. 이때는 직렬화 혹은 동기화가 필요하다고 하는거지.

아예, 둘이 상관없는 일을 하는 경우도 생각해 볼 수 있겠지.
이런 경우는 극히 드물지만, 동기화가 필요없어 안전한 경우기도 하다.
누군가는 데이타를 만들어서 메모리에 적고, 누군가는 화면에 뿌리기만 하는 경우가 되겠다.
대개의 GUI는 Multi threading 을 지원하지 않는다. VCL 이든 C# 이든 Java 환경이든
동기화 문제 때문에 thread unsafe 하다고 말하는경우지.
하지만 그리는걸 한 놈만 관장하고, 읽기 전용으로 데이타에 접근할 때,
이런 비구속적 동기화, 어떻게 보면 비동기적 동시화 구조가 가능하다는 거지.


5. Muti-programming

흔히 듣도 보도 못했을? 단어가 등장한다.
이름만 거창하지 이건 뭐 별거 없어. channel 의 계보를 잇는거고,
위에서 말한 마지막 구조 즉 별도의 동기화가 필요치 않은 동시 처리를 이야기 하는거다.
입출력을 기다리지 않고 주된 처리를 돌리겠다. 즉, 주된 처리 혹은 입출력을 백그라운드로 돌리겠다는 의미를 말한다.
Unix console 명령어 & 가 fork 명령을 겸하는 것 같은거쥐.


6. Muti-thread & Multi-process

자꾸 하고싶은 이야기가 튀어다녀서 좆같다. 시발. ENTP 하여튼 셀프 자살 추천. ㅠㅠ
초기 Unix 시스템들은 thread 개념이 없었다.
POSIX 에서 운영체제 표준을 이야기 하지만, Digital Unix 들은 영영 thread 따윈 없었다.
즉 독립된 메모리 공간(Protection mode)을 사용하는 Process 를 여러개 생성(folk)시켜 동시에(시간을 잘게 나눠) 처리되도록
지원했다는거지. 당연히 독립된 메모리 공간끼리 서로 동기화(synchronize)가 필요한 경우, 서로 통신 할 방법이 필요하다.

그래서 IPC 가 나오게 되었지. (Inter-process-communication)
message queue 니, message 니(이건 좆같은 windows), signal 이니(요건 좀 원초적이군),
memory mapped file 이니, shared memory 니, pipe 니, named pipe 니 하는 것들 말야.
덧붙여. 내 외부, 장치간 통신도 가능하게 하는 socket 멋지쥐. (socket 이거 짱먹음)
여기서 말하고픈건 모든건 필요에 의해서 나왔다 이거야.

IPC 가 무겁지. Process 도 무겁지. 뭐가 무겁냐고? 구현하기 귀찮고 동기화 하기 귀찮고, 시발 다 귀찮다는거여.
그래서 Thread 가 나왔다. (이거 짱먹음)

하나의 프로세스 안에서 같은 메모리 공간을 공유하면
구차하게 파이프 뚫고 개지랄 떨지 않아도 동기화된 동시성을 만족시킬 수 있잖아?
라는 아이디어지.

모든 프로그램은 엔트리 포인트를 가진다. DLL 조차도 Load, Unload 를 위한 Entry point 를 가진다.
Enter 라는게 어떤 의민지는 알쥐? Entry point 라는 것도 같은 맥락에서 해석해라. 진.입.점.
운영체제의 shell 밖에서 응용프로그램이나 사용자, 혹은 운영체제가 어떤 프로그램을 실행한다는건,
실행파일의 포맷을 해석해서(PE든 ELF든 뭐든) 메모리 공간을 확보, 그 위에 풀어놓고,
PC (Program counter 혹은 Instruction Pointer)가 엔트리 포인트로 뛰어간다는걸 의미한다.
즉 C 언어에선 main 함수가 되는거고,
엔트리 포인트의 함수를 실행하는게 프로세스가 생성된다는걸 의미한다는거다.
물론 코드내에서 folk 를 실행하면 실행하는 순간이 entry point 가 되는거고 말야.

이와 마찬가지로, thread 역시 함수 단위로 entry point를 한번 싸준다(wrapping).
코드 내 이곳 저곳에서 실행되는 folk 는 좀 지저분하잖아. 코드 보기 좆같아짐.
쓰레드를 생성시키는 함수를 실행하면, 그 함수에 인자로 전달한 함수를 동시화 실행한단 말씀.
그게 전부.
대신 프로세스와 달리 하나의 프로세스에 할당된 메모리 공간 안에서 여러개의 쓰레드를 만들 수 있으니,
전통적인 folk 와 달리 메모리 사용량이 늘지도 않고, pipe 따위 IPC를 뚫을 필요도 없고,
전역변수나 인자로 전달된 포인터를 통한(구조체 따위의) 참조로 서로의 처리결과를 공유할 수 있다.

다만, 여기서 발생하는 문제가,
하나의 프로세서가 뒈져도 다른 프로세서엔 영향을 미치지 않는데 반해,
하나의 쓰레드가 뒈지면 서로 메모리를 공유하는 쓰레드의 컨테이너, 즉 같은 프로세스 위에 도는 쓰레드는 다 나가 뻗게 된다는거.
그래서 익스플로러 창 하나 뒈지면 바탕화면이 사라진다든지 (바탕화면도 하나의 익스플로러 쓰레드)
하는 좆같은 상황들이 발생하는거지. 뭐 이정도 하면 쓰레드와 프로세스의 썰은 맺어도 되겠지 ㅇㅋ?


7. 남은 주제들

이제 겨우 어떤 이야기의 시작을 만든 것 같은데,
운영체제란 과목을 들어보면 mutex 도 semaphore 도 자원의 접근 권한을 관리하기 위한 하나의 정수(int) 및 관련 연산일 뿐이다.
즉, 개븅신 컴파일러가 제멋대로 최적화 해서 논리적인 오류를 만들어내지 않게 하기 위한 volatile 선언과
if, goto 문만 사용해도 multi-tasking 을 지원해야 하는 운영체제가 가져야 할 기본적인 모든 기능을 만들 수 있어.
하지만 아까 댓글에서 말했듯, 입출력을 감시해 동기화를 이루기 위해 while 문 따위 (if + goto) 를 돌린다면
(내가 polling 구조라고 하는거) CPU 점유율이 증가하게 되고, 이를 손실없이 처리해주는 컴파일러+CPU 조합도 존재하긴 하고,
sleep, yield 등의 함수들로 context switching 을 유도할 순 있지만, 고비용의 처리임은 틀림없지.
그래서 IO 의 event 들을 비동기적(async) 으로 알려주는 함수들이 제공되는 거다.

컨텍스트 스위칭이란 말 그대로 현재 작업중인 레지스터와 스택의 상태를 보존하고 다른 작업으로 넘어가는 것을 말하는데,
snap shot 의 개념이기도 하지.
요즘은 VM 같은 sand-box - 샌드 박스도 뭐 보호메모리 구조랑 다를바는 없쥐 - 에서 복원점을 저장하는 것도 snap shot 이라고 부르긴 하는뎅,
생긴 모양들이 다 거기서 거기 아냐?
작게 작게 보든 크게 크게 보단 다 통신이고 다 context switching 이쥐.
거기서 거기 그나물에 그밥. 와 운영체제 별거 없네.

운영체제가 거대해 보여도,
실상 해주는건 메모리 관리와 멀티태스킹을 위한 context switching, file system 지원, GUI 지원, API 준비, 장치 로더들, 계정 관리, shell 등 몇 가지 안돼.
운영체제, 컴파일러 만들면 신, 이런게 아니라고... 70년대 이전에 만들어진 기술들이 뭐 대단한게 있을것 같냐?

하고픈 말 대충 다 한 것같다.
시부럴 별거 없구나. 미안.
